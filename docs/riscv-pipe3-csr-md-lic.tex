%
% riscv-pipe3-csr-md-lic.tex --
%
% Documentation for the THUAS RISC-V three-stage pipelined processor
%
% (c)2023, J.E.J. op den Brouw <J.E.J.opdenBrouw@hhs.nl>
%

\documentclass[12pt]{article}

\author{Jesse E.J. op den Brouw\thanks{\texttt{J.E.J.opdenBrouw@hhs.nl}}\\[2ex]The Hague University of Applied Sciences}
\title{A RISC-V Microcontroller in VHDL}
\date{\today\\[2ex]\normalsize\url{https://github.com/jesseopdenbrouw/riscv-rv32}\\[2ex]For design \texttt{riscv-pipe3-csr-md-lic}}

\usepackage[a4paper,inner=1.0in,outer=1.2in,top=1in,bottom=1.5in,footskip=0.4in,showframe]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[charter]{mathdesign}
\usepackage[scale=0.92]{nimbusmono}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage{rotating}
\usepackage{register}
\usepackage[english]{babel}
\usepackage{longtable}

%% Making captions nicer...
\usepackage[font=footnotesize,format=plain,labelfont=bf,textfont=sl]{caption}
\usepackage[labelformat=simple,font=footnotesize,format=plain,labelfont=bf,textfont=sl]{subcaption}
\captionsetup[figure]{format=hang,justification=centering,singlelinecheck=off,skip=2ex}
\captionsetup[table]{format=hang,justification=centering,singlelinecheck=off,skip=2ex}
\captionsetup[subfigure]{format=hang,justification=centering,singlelinecheck=off,skip=2ex}
\captionsetup[subtable]{format=hang,justification=centering,singlelinecheck=off,skip=2ex}
%% Put parens around the subfig name (a) (b) etc. Needs labelformat simple
\renewcommand\thesubfigure{(\alph{subfigure})}
\renewcommand\thesubtable{(\alph{subtable})}

% Parskip et al.
\usepackage{parskip}
\makeatletter
\setlength{\parfillskip}{00\p@ \@plus 1fil}
\makeatother

\usepackage{textcomp}
\usepackage{listings}
\lstset{
    basicstyle = \ttfamily,
    numbers = left,
    numberstyle=\tiny\color{gray},
    breaklines = true,
    showspaces = false,
    prebreak = \raisebox{-0.5ex}[0ex][0ex]{\color{red}\ensuremath{\hookleftarrow}},
    postbreak = \raisebox{-0.5ex}[0ex][0ex]{\color{red}\ensuremath{\hookrightarrow}},
    upquote = true,
    tabsize = 4,
}

\usepackage{tikz}
\usetikzlibrary{backgrounds,shapes,arrows,automata,decorations.pathreplacing}

\usepackage{hyperref}
\hypersetup{colorlinks}

\begin{document}
\maketitle

\vfill
\begin{abstract}
\parskip=0.5\baselineskip
\noindent
The RISC-V Instruction Set Architecture (ISA) is an open source instruction set for a processor. This means that anybody can create a processor that uses this instruction set. There are already processors available such as E2-core from SiFive. More freeware cores are available on several platforms (e.g. on GitHub). This documents describes a basic 32-bit RISC-V processor in VHDL. The processor can execute the RV32IM unprivileged instruction set, and most of the instructions from the privileged instruction set. The processor incorporates a ROM, RAM, some simple I/O, a CSR and LIC (local interrupt controller). It is targeted for implementation on an FPGA. It is tested on an Intel Cyclone V with a DE0-CV development board from Terasic with the use of Quartus Prime Lite 21.1 and QuestaSim Intel Starter Edition 2021.2. The GNU C-compiler for RISC-V is used for software development. Many C programs were successfully tested using the GNU C compiler. C++ is supported but most standard concepts create a binary that is too big to fit in the ROM.

\noindent
This processor is not intended as a replacement for commercial available processors. It is intended as a study object for Computer Science students.

\noindent
The processor has a three-stage pipeline and executes each instruction in three clock cycles, but the next instructions are fetched and decoded while the current instruction is executed. Jump/branches taken require three clock cycles. ROM, RAM and I/O reads need two clock cycles. This processor also has a basic Control and Status Registers (CSR) set, suitable to handle traps, and a hardware integer multiplier/divider. This version incorporates a bootloader.

\noindent
This is work in progress. Things will certainly change in the future.
\end{abstract}
\vfill

\clearpage
\tableofcontents

\clearpage
\section{Introduction}
This document describes the buildup of a simple, one core, RISC-V processor, completely written in VHDL. The core contains one HART (Hardware Thread). The processor is able to run a compiled C-program. C++ is supported but some concepts (\texttt{cout} with \texttt{iostream}, STL) create binaries that is too big to fit in the ROM. The processor can handle the RV32IM Base Integer Instruction Set as set forward in ``The RISC-V Instruction Set Manual Volume I: Unprivileged ISA''. The processor can handle traps (interrupts/exceptions). The aim is to synthesize for a clock frequency of 80\,MHz. The processor utilizes ROM, RAM and some simple I/O (including MTIME and MTIMECMP) effectively making it a microcontroller.

The processor requires three clock cycles to complete an instruction, but the next instructions are fetched and decoded while the current instruction is executed. Jumps, calls and branches taken require three clock cycles because an new instruction has to be fetched. Also, two clock cycles are needed when reading ROM (data), RAM and I/O. ROM and RAM are implemented using onboard RAM block (which are buffered with an output register). The I/O output has a buffer register to speed up the processor. The processor has a basic Control and Status Registers set, offering [M]CYCLE and [M]CYCLEH (completed clock cycles), MTIME and MTIMEH (time since last reset, in microseconds, shadowed from memory mapped registers), [M]INSTRET and [M]INSTRETH (number of retired instructions), and a basic set of CSRs to handle traps. A hardware multiplication requires three clock cycles to complete. A hardware division requires 32+2 or 16+2 clock cycles to complete, depending on the settings. CSR operations require one clock cycle.

The processor executes at top 1 CPI (clocks per instruction) with a sequential flow of instructions. A preliminary test with CoreMark showed a CPI of 1.52.

\section{The processor}
The RISC-V processors consist of one \textit{core} and some building blocks:

The core:
\begin{itemize}
\item The registers contain intermediate data for calculations. The registers may be placed in onboard RAM of ALM flip-flops.
\item The ALU is responsible for almost all computations in the processor.
\item The PC is used to point to the currently fetched instruction (not the instruction that is currently being executed).
\item The Instruction Decoder decodes the fetched instruction and provides control signals to other building blocks.
\item The multiply/divide unit calculates integer multiplications, divisions and remainder.
\item The control unit regulates the data flow and control flow in the core.
\end{itemize}

The remaining building blocks:
\begin{itemize}
\item The ROM contains the program instructions and constant data. When the bootloader is implemented, the ROM may be written.
\item The bootloader ROM contains the program instructions and constant (read-only) data. The boorloader ROM may be excluded from the design
\item The RAM contains read-write data (mutable data).
\item The I/O is an interface with the outside world.
\item The Address Decoder and Data Router is an interface between the memory (ROM, BOOT, RAM, I/O) and the ALU and registers.
\item The instruction router routes instructions from the ROM and the boot ROM (if enabled).
\item The Control and Status Registers contains a basic set of register.
\item The Local Interrupt Controller determines which trap is to be served.
\end{itemize}

A block diagram of the core is shown in Figure~\ref{fig:blockdiagram}.

\begin{sidewaysfigure}[!p]
\centering
\begin{tikzpicture}[thick,font=\sffamily\footnotesize,>=latex,scale=.75,framed,background rectangle/.style={fill=none}]
% PC and Instruction ROM
\draw (0,0) rectangle node {PC} (2,-4);
\draw[-latex] (2,-2) -- (4,-2);
\draw (4,0) rectangle node[align=center] {ROM\\(instr)} (6,-4);
\draw (7,4) node[xshift=0.3cm,yshift=10pt] {IF/ID} rectangle node {} (8,-8);
\draw[-latex] (6,-2) -- (7,-2);
\draw[-latex] (3,-2) -- ++(0,5.333) -- ++(4,0);
\draw[-latex] (8,3.333) -- ++(6,0);
\draw[-latex] (15,3.333) -- ++(1,0) -- ++(0,2) -- ++(-17,0) -- ++(0,-6) --++(1,0);

% Registers et al
\draw (10,2) rectangle node {regs} (11.667,0);
\draw (11.667,1) rectangle ++(0.333,1);
\draw (11.667,0) rectangle ++(0.333,1);
\draw[-latex] (12,1.5) -- node[above] {rs1} ++(2,0);
\draw[-latex] (12,0.5) -- node[above] {rs2} ++(2,0);
\draw[-latex] (8,-4.5) -- ++(2,0);
\draw[-latex] (8,-5.0) -- ++(2,0);
\draw[-latex] (8,-5.5) -- ++(2,0);
\draw[-latex] (12,-5) -- ++(2,0);
\draw[] (10-0.333, 0.667) rectangle ++(0.333,-0.667);
\draw[] (10,-4) rectangle node {imm} (12,-6);
\draw[-latex] (8,1.667) -- ++(2,0);
\draw[-latex] (8,1.667-.5) -- ++(2,0);
\draw[] (10,-1) rectangle node[] {decoder} ++(2,-2);
\draw[-latex] (8,-2) -- ++(2,0);
\draw[-latex] (12,-2) -- ++(2,0);
 

% ID/EX
\draw (14,4) node[xshift=0.3cm,yshift=10pt] {ID/EX} rectangle node {} (15,-8);
\draw[] (15,-5) -- ++(3,0) coordinate (w) -- ++(0,3.000);
\draw[-latex] (w) -- ++(0,-4) -- ++(-19,0) -- ++(0,5.667) -- ++(1,0);
\draw (17,3) rectangle node{fw} ++(1,-2);
\draw[-latex] (15,2.667) -- ++(2,0);
\draw[-latex] (15,1.667) -- ++(2,0);

% ALU
\draw[] (19,3) -- ++(1,-1) -- ++(0,-3.333) -- ++(-1,-1.0) -- cycle; %++(0,3.333);
\draw[-latex] (18,-2.000) -- ++(1,0);
\draw[-latex] (18,2.667) -- ++(1,0);
\draw[-latex] (18,1.667) -- ++(1,0);
\draw[-latex] (18.5,2.667) -- ++(0,3.5) -- ++(-20.5,0) -- ++(0,-7.667) -- ++(2,0);
\draw[-latex] (18.0,0.5) node[left] {CSR} -- ++(1,0);
\draw[-latex] (18.0,0.0) node[left] {MD} -- ++(1,0);
\draw[-latex] (18.0,-0.5) node[left] {mem} -- ++(1,0);
\draw[-latex] (18.0,-1.0) node[left] {ID/EX.PC} -- ++(1,0);

% ALU out
\draw[-latex] (20,0.333) -- ++(2,0) -- ++(0,-7.0) coordinate (x) -- ++(-2,0);
\draw[] (20,-6+0.1667/2) rectangle node {fwrd} ++(-1,-1.5);

\draw[-latex] (19,-6.667) -- ++(-3,0) coordinate (z) -- ++(0,9) -- ++(1,0);
\draw[-latex] (16,1.333) -- ++(1,0);
%\draw[-latex,red] (z) -- ++(0,-8) -- ++(-18,0) -- ++(0,8) -- ++(2,0);

\draw[-latex,] (x) -- ++(0,-3) -- ++(-13,0) coordinate (y) -- ++(0,10) -- ++(0.667,0) node[below,yshift=-7pt] {rd};
;
\end{tikzpicture}
\caption{Overview of the RISC-V core. Not all connections are shown.}
\label{fig:blockdiagram}
\end{sidewaysfigure}

\subsection{Registers}
The register file consists of thirty-two 32-bit registers denoted by \texttt{x0} to \texttt{x31}. Internally, the registers use Big Endian format. Register \texttt{x0} (alias \texttt{zero}) is hardwired to all zeros. Writing this register has no effect. Reading this register returns all zero bits. Normally, the \texttt{x}-names are not used but may be handy when simulating the designs. Table~\ref{tab:registers} shows the names of the registers as they should be used.

A register can be written to, and two register can be selected for data and/or base address.

\begin{table}[!ht]
\centering
\caption{RISC-V registers and their purpose.}
\label{tab:registers}
\begin{tabular}{lllc}
Register & Name & Purpose & Saver \\
\midrule
\texttt{x0}      & \texttt{zero}   & Hard-wired zero                   & $-$ \\
\texttt{x1}      & \texttt{ra}     & Return address                    & Caller \\
\texttt{x2}      & \texttt{sp}     & Stack pointer                     & Callee \\
\texttt{x3}      & \texttt{gp}     & Global pointer                    & $-$ \\
\texttt{x4}      & \texttt{tp}     & Thread pointer                    & $-$ \\
\texttt{x5}      & \texttt{t0}     & Temporary/alternate link register & Caller \\
\texttt{x6-x7}   & \texttt{t1-t2}  & Temporaries                       & Caller \\
\texttt{x8}      & \texttt{s0/fp}  & Saved register/frame pointer      & Callee \\
\texttt{x9}      & \texttt{s1}     & Saved register                    & Callee \\
\texttt{x10-x11} & \texttt{a0-a1}  & Function arguments/return values  & Caller \\
\texttt{x12-x17} & \texttt{a2-a7}  & Function arguments                & Caller \\
\texttt{x18-x27} & \texttt{s2-s11} & Saved registers                   & Callee \\
\texttt{x28-x31} & \texttt{t3-t6}  & Temporaries                       & Caller
\end{tabular}
\end{table}

The register can optionally be put in onboard RAM blocks. This saves a lot of ALM flip-flops but possibly lowers the system frequency.

\subsection{ALU}
\label{sec:alu}
The Arithmetic and Logic Unit (ALU) handles all computations on data. It can add, subtract, do logic operations such as AND, OR en XOR, can shift data left or right, and sign extend byte and half word data. Some operations require two registers, some only use one register. Some instructions use one register and immediate data. Furthermore the ALU is also used to determine if a conditional branch should be taken. Note that the RISC-V programmer's model does not incorporate status flags as some other architectures do. This requires some extra instructions when adding or subtracting double word (64-bit) data. This is handled by the C compiler. The ALU is also used to compute the return address from unconditional function calls (JAL and JALR instructions). The data is in Big Endian format. The ALU is the only building block that can write registers. The ALU does not compute multiplications and divisions, but merely passes on data from the MD unit.

Note that the computation of jump target addresses is handled by the Program Counter (PC) hardware.

\subsection{PC}
\label{sec:pc}
The Program Counter contains the address of the currently fetched instruction. The address is always on a 4-byte boundary although function calls and conditional jump (JAL, JALR en B$xx$ instructions) can be on non 4-byte boundaries (the C compiler will always create 4-bytes boundaries). The PC (or rather the VHDL description of the PC) handles the address calculations of jumps and branches taken.

\subsection{Instruction Decoder}
\label{sec:instructiondecoder}
The instruction decoder decodes the instruction supplied by the ROM as pointed by the PC. An instruction is 4 bytes wide and in Little Endian order. The instruction decoder provides all control signals for the ALU, RAM, ROM, I/O, the PC, the Address Decoder, the CSR, the register file and the MD unit. Some signals are directly wired to the ROM, RAM and I/O.

\subsection{Control Unit}
The processor uses a ten-state FSM, see figure~\ref{fsmpipe}. The PC points to +8 of the currently executing instruction, in a sequential instruction stream. If a jump or branch taken occurs, the FSM inserts a penalty because the PC has to be loaded with the correct value and a new instruction must be fetched (Figure~\ref{fsmpipeseqstartup}). Reading RAM, ROM and I/O requires an extra state (Figure~\ref{fsmpipeseqwait}). When a multiply, divide or remainder instruction is encountered, the FSM enters the \texttt{md} state and waits for the md-unit to complete (32+2 or 16+2 clock cycles). Note that penalty, wait and md\_start cannot occur at the same time.

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[node distance=3cm]
\node[state,initial,initial text=reset] (boot0) {boot0};
\node[state,right of=boot0] (boot1) {boot1};
\node[state,right of=boot1] (exec) {exec};
\node[state,right of=exec] (wait) {wait};
\node[state,above of=exec] (md) {md};
\node[state,below of=exec] (flush) {flush};
\node[state,initial, initial text=trap*, below of=boot0] (intr) {intr};
\node[state,right of=intr] (intr2) {intr2};
\node[state,above of=boot0] (mret) {mret};
\node[state,right of=mret] (mret2) {mret2};

\path[-latex] (boot0) edge node[above] {--} (boot1)
              (boot1) edge node[above] {--} (exec)
              (exec) edge [bend right] node[above] {wait} (wait)
              (wait) edge [bend right] node[above] {--} (exec)
              (exec) edge [bend right] node[right] {md\_start} (md)
              (md) edge [bend right] node[left] {md\_ready} (exec)
              (exec) edge [bend right] node[left] {penalty}  (flush)
              (flush) edge [bend right] node[right] {--} (exec)
              (intr) edge node[above] {--} (intr2)
              (intr2) edge [bend left] node[left] {--} (exec)
              (exec) edge [bend left=10] node[left,xshift=-7pt] {mret} (mret)
              (mret) edge node[above] {--} (mret2)
              (mret2) edge [out=270, in=140] node[left,xshift=-5pt] {--} (exec)
;
\node at (0,-4) {\small * trap initiated by hardware or software.};
\end{tikzpicture}
\caption{FSM of the instruction flow of the processor.}
\label{fsmpipe}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[node distance=2cm, line width=1pt]
\draw[-latex,dashed] (-1,-0.5) -- ++(1,0);

\draw (0,0) rectangle node [] {fetch} ++(2,-1);
\node at (1,0) [above] {PC};
\draw[-latex] (2,-0.5) -- ++(1,0);

\draw (3,0) rectangle node [] {decode} ++(2,-1);
\node at (4,0) [above] {PC+4};
\draw[-latex] (5,-0.5) -- ++(1,0);

\draw (6,0) rectangle node [] {exec} ++(2,-1);
\node at (7,0) [above] {PC+8};
\draw[-latex] (8,-0.5) -- ++(1,0);

\draw (9,0) rectangle node [] {exec} ++(2,-1);
\node at (10,0) [above] {PC+12};
\draw[-latex,dashed] (11,-0.5) -- ++(1,0);

\draw [thick,decorate,decoration={brace,amplitude=10pt,mirror},xshift=0.4pt,yshift=-10pt](0,-1) -- (8,-1) node[black,midway,yshift=-0.6cm] {\footnotesize one instruction};
\draw [thick,decorate,decoration={brace,amplitude=10pt,mirror},xshift=0.4pt,yshift=-10pt](9,-1) -- (11,-1) node[black,midway,yshift=-0.6cm] {\footnotesize one instruction};
\end{tikzpicture}
\caption{State sequence for start up/penalty with instruction execution (no wait state).}
\label{fsmpipeseqstartup}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[node distance=2cm, line width=1pt]
\draw[-latex,dashed] (-1,-0.5) -- ++(1,0);

\draw (0,0) rectangle node [] {exec} ++(2,-1);
\node at (1,0) [above] {PC};
\draw[-latex] (2,-0.5) -- ++(1,0);

\draw (3,0) rectangle node [] {exec} ++(2,-1);
\node at (4,0) [above] {PC+4};
\draw[-latex] (5,-0.5) -- ++(1,0);

\draw (6,0) rectangle node [] {wait} ++(2,-1);
\node at (7,0) [above] {PC+4};
\draw[-latex] (8,-0.5) -- ++(1,0);

\draw (9,0) rectangle node [] {exec} ++(2,-1);
\node at (10,0) [above] {PC+8};
\draw[-latex,dashed] (11,-0.5) -- ++(1,0);

\draw [thick,decorate,decoration={brace,amplitude=10pt,mirror},xshift=0.4pt,yshift=-10pt](0,-1) -- (2,-1) node[black,midway,yshift=-0.6cm] {\footnotesize one instruction};
\draw [thick,decorate,decoration={brace,amplitude=10pt,mirror},xshift=0.4pt,yshift=-10pt](3,-1) -- (8,-1) node[black,midway,yshift=-0.6cm] {\footnotesize one instruction};
\draw [thick,decorate,decoration={brace,amplitude=10pt,mirror},xshift=0.4pt,yshift=-10pt](9,-1) -- (11,-1) node[black,midway,yshift=-0.6cm] {\footnotesize one instruction};
\end{tikzpicture}
\caption{State sequence for instruction execution (wait state).}
\label{fsmpipeseqwait}
\end{figure}

\subsubsection{Trap handling}
When an interrupt occurs, the FSM enters the \texttt{intr} state for fetching the trap vector. An interrupt can occur any time and is called asynchronous. When an interrupt occurs,
the current instruction is discarded and must be restarted after return. After fetching the trap handler, new instructions are fetched and the instruction pipeline is flushed.

Exceptions are synchronous to the executing of instructions. When a exceptions occurs, the current instruction is discarded and must be restarted after return. Exceptions to this are the ECALL and EBREAK instructions. These instructions do cause a trap, but are not restarted, so the next instruction is fetched after return. This is handled by the CSR hardware, no software intervention is needed.

When a trap request is asserted, the trap vector is loaded in the next clock cycle. Then, in the second clock cycle, the instruction is fetched and in the third clock cycle the instruction is decoded and in the fourth cycle the instruction is executed. On return from a trap handler, the original contents of the PC is fetched from the CSR and then instructions are fetched. A return flushes the pipeline.


\subsection{Address Decoder and Data Router}
\label{sec:addressdecoderanddatarouter}
The Address Decoder and Data Router routes reads and writes to the ROM, bootloader ROM (only reads), RAM and the I/O. The processor uses a 32-bit linear address space for ROM, RAM and I/O. In the default setting, ROM starts at address 0x00000000 and the length is 64 kB. The bootloader ROM starts at address 0x10000000 and the length is 4 kB. Unused ROM addresses return 0x0000000. The RAM starts at address 0x20000000 and length is 32 kB. The I/O starts at address 0xF0000000 and the length is 16 kB by default.

When data is read, the data is collected from the accessed memory and put on an internal bus to the ALU. The ALU can perform sign extension (byte and half word accesses) if needed. Please note that reading data from the RAM, (bootloader) ROM and I/O requires two clock cycles.

Note that instructions can only be fetched from ROM and boot ROM.

\subsection{Instruction Router}
The Instruction Router routes instructions from the ROM and the boot ROM. If the boot ROM is disabled, the synthesizer will remove this block.

\subsection{Control and Status registers}
The RISC-V specification describes a set of 4096 control and status register in a separate address space. CSR operations require one clock cycle. Basic event counters are implemented:

\begin{itemize}
\item \lstinline|cycle| and \lstinline|cycleh| -- these 32-bit registers form a 64-bit value that contains the counted clock cycles since the last reset.
\item \lstinline|time| and \lstinline|timeh| -- these registers shadow the contents of the \lstinline|MTIME| and \lstinline|MTIMEH| registers from the I/O.
\item \lstinline|instret| and \lstinline|instreth| -- these 32-bit registers form a 64-bit value that contains the counted retired instructions since the last reset.
\end{itemize}

Note that these registers are read-only. Writes are ignored. 

Generic registers:

\begin{itemize}
\item \lstinline|mvendorid| -- this register is hardwired to all zero bits.
\item \lstinline|marchid| -- this register is hardwired to all zero bits.
\item \lstinline|mimpid| -- this register is hardwired to all zero bits.
\item \lstinline|mhartid| -- this register is hardwired to all zero bits.
\item \lstinline|mconfigptr| -- this register is hardwired to all zero bits.
\item \lstinline|misa| -- hardwired to value 0x40001100, indicating 32-bit processing, RV32I base ISA and Integer Multiply/Divide extension.
\end{itemize}

For trap handling, the following registers are implemented:

\begin{itemize}
\item \lstinline|mstatus| -- the only implemented bits are \lstinline|MIE|, \lstinline|MPIE| and \lstinline|MPP|, all other bits are hardwired zero.
\item \lstinline|mie| -- for the lower 16 bits, only \lstinline|MTIE| is implemented, all other bits are hardwired zero.
\item \lstinline|mtvec| -- contains the trap handler (vector) address, can be used in direct and vectored mode.
\item \lstinline|mstatush| -- this register is hardwired to all zero bits.
\item \lstinline|mscratch| -- currently not used, but can be used by software trap handlers.
\item \lstinline|mepc| -- contains the PC at point of trap of the \emph{currently} executing instruction.
\item \lstinline|mcause| -- contains the cause of the trap as set forward in ``The RISC-V Instruction Set Manual, Volume II: Privileged Architecture''. For local interrupts, additional codes are used.
\item \lstinline|mtval| -- contains the address on the address bus when a trap occurs, not always relevant.
\item \lstinline|mip| -- contains the pending interrupts. For the lower 16 bits, only \lstinline|MTIP| is implemented. The upper 16 bits are used for local interrupts. This register is read-only.
\item \lstinline|mconfigptr| -- this register is hardwired to all zero bits.
\item \lstinline|mcountinhibit| -- this register has bit 2 (\lstinline|[m]instret|and 0 (\lstinline|[m]cycle|)implemented.
\end{itemize}

The \lstinline|mcounteren| register are not implemented, because U-mode is not implemented. The \lstinline|menvcfg| and \lstinline|menvcfgh| are not implemented, because only M-mode is implemented.

The trap handler (vector) address must be loaded by software at boot time. Both direct and vectored mode are supported. In direct mode all traps redirect to a single trap handler that has to handle both interrupts and exceptions. The most significant bit of \lstinline|mcause| is 1 when a trap occurred from an interrupt. In vectored mode, the addresses of \emph{interrupt handlers} are loaded from a jump table. Exceptions are redirected to a single handler. Note that the address of the jump table must be on a 4-byte boundary, and bit 0 of the jump table address has to be set to 1 for vectored mode.

Other CSRs are not implemented. Good synthesizers will remove unused CSRs.

\subsection{Local Interrupt Control unit}
The Local Interrupt Controller is responsible for selecting which trap request must be serviced by the core. Interrupts have higher priority than exceptions. The state of the serviced trap is visible in the CSR.

The LIC can handle 16 local interrupts (numbered 16 to 31) and the Machine mode external timer interrupt (numbered 7). Other standard RISC-V interrupts (numbered 0 to 6 and 8 to 15) are not available. The external timer interrupt has the highest priority, followed (currently) by the SPI1, TIMER2, USART and TIMER1 interrupts.

Exceptions are handled as set forward in Table 3.7 of ``The RISC-V Instruction Set Manual, Volume II: Privileged Architecture'': instruction access fault, instruction address misaligned, ECALL (M mode only), EBREAK, load/store address misaligned, load/store access fault. Note that ECALL and EBREAK are user instructions and can be interrupted by an interrupt (i.e. when the ECALL or EBREAK instruction is executing).

\subsection{Multiply/Divide Unit}
The processor is equipped with a hardware integer multiply/divide unit. All multiply/divide instructions are supported (\lstinline|MUL|, \lstinline|MULH|, \lstinline|MULHSU|, \lstinline|MULHU|, \lstinline|DIV|, \lstinline|DIVU|, \lstinline|REM|, \lstinline|REMU|) and the result is fed to the ALU. A multiplication takes three clock cycles (one clock-in, one multiply, one clock-out). For division, two versions are available. By default, the divider needs 18 clocks (one clock-in, 16 divide, one clock-out) for a division using a poor man's radix-4 division unit. As an alternative, a simple radix-2 division unit can be selected taking 34 clock cycles (one clock-in, 32 divide, one clock-out) to do the division.  Thus, the radix-4 divider unit is faster, but needs more cells. The radix-2 divider unit is slower, but needs less cells. You have to enable the M-standard support in the compiler. The multiplier uses special DSP units in the Cyclone V. Most regular FPGAs have onboard multipliers. Note that when executing an operation, the pipeline is stalled. Also note that a trap can interrupt the computation, and then the instruction has to be restarted. Selecting the radix-4 division has a minimum impact on the clock speed.


\subsection{Stack pointer}
The stack pointer is fully implemented although the ISA does not provide pushes and pops. The stack pointer is used to allocate local variables and is updated with each allocation and deallocation. As usual, the stack grows downwards (to lower addresses) on allocations and upwards (to higher addresses) on deallocations. Therefore the stack pointer is set to the highest RAM address + 1 on boot (which is 0x20008000 by default). The ISA postulates that the stack is aligned on 16-byte boundaries for the I standard.

\subsection{ROM}
\label{sec:rom}
The ROM consists of bytes and is only word addressable for instructions. The ROM is byte, half word and word addressable when reading constant data. Half word and word entries are in Litte Endian format. When reading data from the ROM, half word accesses must be on 2-byte boundaries and word accesses must be on 4-byte boundaries. This simplifies the decoding circuitry. The ROM returns undefined data if an access is not aligned. The processor instantiates the ROM in onboard RAM. Rearranging half word and word data accesses in Big Endian format is handled by the ROM decoding unit. Reading ROM (both instructions and data) requires two clock cycles.  This is automatically handled by the processor. The pipeline is stalled for one clock cycle when reading from ROM (data).

Note: the Cyclone V has 3,153,920 bits of onboard RAM available. Because of the 32-bit entries a maximum of 2,097,152 (65536 x 32) bits can be instantiated. This is equivalent to 262,144 bytes.

Note: instructions can only be fetched from the ROM and bootloader ROM. Note: when the bootloader is synthesized in the FPGA, the ROM may also be written with 32-bit data on 4-byte boundaries.

\subsection{Booloader ROM}
\label{sec:bootloaderrom}
The bootloader ROM contains a small program to upload S-record files in the ROM. The bootloader ROM cannot be written by an upload. Besides that, the bootloader contains a simple monitor program. The bootloader ROM is places in onboard immutable RAM blocks. See Section~\ref{sec:bootloader}. The bootloader may be excluded from synthesis.

\subsection{RAM}
\label{sec:ram}
The RAM consists of bytes and is byte, half word and word addressable. Half word and word entries are in Little Endian format. The RAM itself is made up of word (i.e. 32-bit) entries and is instantiated with onboard RAM blocks. Due to this fact, half word accesses are only permitted on 2-byte boundaries and word accesses are only permitted on 4-byte boundaries. The RAM returns undefined data if an access is not aligned. Writes will not take place if an access is unaligned. This simplifies the decoding circuitry. For the Cyclone V a maximum of 65536 words of RAM can be instantiated. Rearranging half word and word data accesses in Big Endian format is handled by the RAM decoding unit. The RAM cannot be used for program data.

Note: the Cyclone V has 3,153,920 bits of onboard RAM available. Because of the 32-bit entries a maximum of 2,097,152 (65536 x 32) bits can be instantiated. This is equivalent to 262,144 bytes.

Reading the RAM (byte, half word, word) requires two clock cycles because the RAM output is buffered by a register. This is automatically handled by the processor. The pipeline is stalled for one clock cycle.

\subsection{I/O}
\label{sec/io}
Currently, the I/O consists of one 32-bit data input and one 32-bit data output, a simple UART, a simple timer, a more elaborate timer, an minimal I\textsuperscript{2}C peripheral, a general purpose SPI peripheral with interrupt, a dedicated SPI peripheral for SD card access and the TIME and TIMEH memory mapped time registers. Note that the I/O can only be accessed as words and the addresses must be on 4-byte boundaries. If not on a 4-byte boundaries or not word size reads/writes, reads return undefined data whereas writes will not write data. A read requires two clock cycles (the pipeline is stalled for one clock cycle), a write requires one clock cycle. Note that not all I/O addresses are used.

The GPIO has separate inputs and output, both 32 bits. This is because some FPGAs/synthesizers don't allow buried tri-state signals, i.e.\@ the tri-state action must be done in the top level entity. Because of that, there is no data direction register. Currently the inputs come from the slide switches and the push buttons. Note that KEY4 a.k.a.\@ FPGA\_RESET is connected to the reset of the processor. The outputs are connected to the 10 red leds and to the two least significant 7-segment displays. Also two output pins are connected to facilitate software generated NSS signals.

The UART can transmit and receive data at 7, 8 or 9 bits, no/even/odd parity and 1 or 2 stop bits. Tested speeds are 9600 bps, 115200 bps and 230400 bps. Several status flags are implemented to guide transmission. Note: more identical UARTs will be added. Receive and transmitted character (local) interrupts are provided (one vector). These interrupt requests must be negated by software. The UART does not provide hardware flow control.

TIMER1 has a 32-bit time register and increments on every clock cycle. It does not have a prescaler. It counts up to compare match T register, after which is will be loaded with 0 again. A compare match (local) interrupt is provided (one vector). Whenever the timer count register is greater than or equal to the compare match T register, an interrupt request is asserted. The interrupt request has to be negated by software. A value of 0 in the compare match T register is valid: the counter does not count, but the compare match (local) interrupt is asserted.

TIMER2 has a 16-bit time register and a 16-bit prescaler, and increments on every clock cycle. It counts up to compare match T register, after which is will be loaded with 0 again. Compare match (local) interrupts are provided (one vector). Whenever the timer count register is greater than or equal to the compare match T register, an interrupt request is asserted. The interrupt request has to be negated by software. The timer provides three more compare registers (A, B, C). Whenever the timer count register is greater than or equal to a compare register (A, B, C) the respective interrupt request is asserted. The interrupt requests have to be negated by software. A value of 0 in the compare match T register is valid: the counter does not count, but the compare match T (local) interrupt is asserted and the compare match interrupts (A, B, C) are asserted whenever the respective compare match register is 0. The prescaler is always preloaded: if the timer is off, the shadow prescaler register is directly written, if the timer is running, the preload register is written and the shadow register is updated at the the next CMPT match. The CMPT/A/B/C registers may optionally use a preload register. If preload is off, the shadow registers are directly written, if preload is on, the preload registers are written and the shadow registers are updated at the next CMPT match.

\textbf{Preliminary!}
I2C1 is a minimized I\textsuperscript{2}C controller peripheral (master-only). It cannot react to clock stretching and lost arbitration, so only modern targets (slaves) can be connected in a one-master-only system. Both Standard mode (Sm) with a transmission speed of up to 100 kbps and Fast mode (Fm) with a transmission speed of 400 kbps are implemented. Before sending the address byte, the send-start bit must be set and a START is send to the target when the address is written to the I2C1 data register. Before sending or receiving the last data byte, the send-stop bit must be set and a STOP is send to the target after the byte is send to the target or received by the controller. When the read-write bit is set to write, the controller may send another byte when the previous byte is send. When the read-write bit is set to read, the controller switches to read mode and will continuously send clock pulses to read data until the send-stop bit is activated (of course in the last byte to receive). After that, the controller may start transmission again. When reading data, the data from the target is always acknowledged. When an address byte is send and no target responds, a STOP is automatically send, unless the disable-stopbit-generation bit is active. In that case, no STOP is send and the controller may issue a repeated-START. The baud rate prescaler must be loaded with the number of system clock cycles of \textbf{one-half} bit time minus~1 for Standard mode and \textbf{one-third} bit time for Fast mode. Note that the prescaler is part of the control register CTRL and its value must be preserved when setting or clearing other bits.

SPI1 is a full-fledged SPI master. It can transfer 8-bit, 16-bit, 24-bit and 32-bit data in one SPI cycle. It incorporates a programmable prescaler (from /2 to /256 in powers of 2) and all four phases of clock polarity (CPOL) and phase polarity (CPHA), hardware NSS (Slave Select, active low) and programmable Slave Select setup and hold time. It is possible to use a GPIO pin to use software-controlled NSS.

SPI2 is a simple SPI master dedicated for the micro SC card reader. It can transfer 8-bit, 16-bit, 24-bit and 32-bit data in one SPI cycle. It does not have an hardware NSS signal and no interrupt capability. A single I/O pin is needed for NSS.

The I/O incorporates memory mapped TIMEH:TIME and TIMECMPH:TIMECMP registers. Whenever TIMEH:TIME (as viewed as a 64-bit register) is greater than or equal to TIMECMPH:TIMECMP (as viewed as a 64-bit register) an interrupt request is asserted (one vector). The interrupt request is negated if TIMEH:TIME is less than TIMECMPH:TIMECMP. This has to be handled by software.

\subsection{Implemented instructions}
For the processor, all RV32IM Unprivileged instructions are implemented but the FENCE instruction act as a no-operation (NOP). From the privileged instruction, ECALL and EBREAK are supported and execute an exception. MRET is used to return from an exception or an interrupt. WFI is not implemented and act as a no-operation (NOP).

\section{The FPGA}
For this project, we use the Cyclone V FPGA from Intel (formerly Altera). See \url{https://www.intel.com/content/www/us/en/products/details/fpga/cyclone/v.html}.
The used Cyclone V is the 5CEFA4F23C7 which has 18480 ALMs available. It has 3080 kb of onboard RAM bits available which are used for RAM, ROM, (possibly) bootloader ROM and (possibly) the registers. Depending on the program and used resources, the compiled RISC-V processor uses about 3000 ALMs (about 17\,\%) and 1,343,488 bits of internal memory (43\,\%). The clock frequency is approximately 80\,MHz, which is sufficient for all program examples. Note that the DE0-CV board has a onboard clock generator with a frequency of 50\,MHz, so a PLL is needed to get a frequency of 80\,MHz. This FPGA is mounted on a Terasic DE0-CV board. The board has 10 switches, 4 push buttons, 1 reset push button, 10 leds, and 6 seven-segment displays. It also has two 2x20-pin headers to connect off-board devices. See \url{http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&No=921}. For downloading the bitstream file, the onboard USB-Blaster is used.

Disabling the bootloader saves one copy of the ROM and the bootloader ROM. Then the used RAM is 786,432 bits (25\,\%). Disabling registers in RAM saves 2048 bits, but increases the ALM count.

It is possible to add the Quartus' Signal Tap (embedded) Logic Analyzer. Follow the instructions on \url{https://people.ece.cornell.edu/land/courses/ece5760/Quartus/Signal_tap.html}. Note that the Signal Tap uses onboard memory.

To find the best compilation result for speed and/or area, we have to tweak the compiler setting for the synthesizer and the fitter. Best is to do a design space exploration, and randomize the seed. Tweaking the seed may show a difference of 5\,MHz on the clock speed.

Table~\ref{tab:util} gives some estimates on the design. In all cases, the seed is set to 1 and the optimization is set to balanced. The total amount of ALMs is 18480. The total amount of RAM bits is 3153920.

\begin{table}[!ht]
\caption{FPGA resource utilization.}
\label{tab:util}
\centering
\begin{tabular}{lllll}
\toprule
     & \begin{tabular}[c]{@{}l@{}}no boot\\ no reg in ram\end{tabular} & \begin{tabular}[c]{@{}l@{}}no boot\\ reg in ram\end{tabular} & \begin{tabular}[c]{@{}l@{}}boot\\ no reg in ram\end{tabular} & \begin{tabular}[c]{@{}l@{}}boot\\ reg in ram\end{tabular} \\ \midrule
Freq & 83.33                                                              & 80.50                                                           & 77.31                                                           & 79.05                                                        \\
ALM  & 3213                                                            & 2664                                                        & 3210                                                         & 2733                                                      \\
RAM  & 786,432                                                         & 788,480                                                      & 1,343,488                                                    & 1,345,536                                                 \\ \bottomrule
\end{tabular}
\end{table}

\section{Processor hardware}
The processor hardware is composed of the following VHDL files:

\begin{itemize}
\item \lstinline|processor_common.vhd| -- Common types and constants.
\item \lstinline|processor_common_rom.vhd| -- Description of the ROM contents.
\item \lstinline|address_decode.vhd| -- The address decoder and data router to the memory \item \lstinline|core.vhd| -- The core contains the PC, the registers, the ALU, the MD unit, the control state machine and the memory interface.
\item \lstinline|instr_router.vhd| -- Description of the instruction router.
\item \lstinline|rom.vhd| -- Description of the ROM. Will be placed in onboard, initialized RAM blocks. 
\item \lstinline|bootloader.vhd| -- Description of the bootloader ROM. Will be placed in onboard, initialized RAM blocks. 
\item \lstinline|ram.vhd| -- Description of the RAM. Will be placed in onboard, uninitialized RAM blocks. 
\item \lstinline|io.vhd| -- Description of the I/O. It contains a 32-bit input register, a 32-bit output register, an UART, a simple timer and the TIME and TIMECMP memory mapped registers.
\item \lstinline|csr.vhd| -- Description of the Control and Status registers.
\item \lstinline|lic.vhd| -- Description of the Local Interrupt Controller.
\item \lstinline|riscv.vhd| -- Top-level description of the processor. Connects all the building blocks to a viable processor.
\item \lstinline|riscv.sdc| -- Constraints file. Sets the target clock frequency.
\item \lstinline|tb_riscv.vhd| -- VHDL testbench to simulate the design.
\item \lstinline|tb_riscv.do| -- QuestaSim/Modelsim command script.
\end{itemize}

In the file \lstinline|processor_common.vhd|, a number of constant parameters are available:
\begin{itemize}
\item \lstinline|SYSTEM_FREQUENCY| -- Set to 50 MHz. Change this if you use a PLL with a different frequency.
\item \lstinline|CLOCK_FREQUENCY| -- Set to 1 MHz. Used to calibrate the internal clock. The compiler assumes 1 MHz and some library functions depend on it.
\item \lstinline|NUMBER_OF_REGISTERS| -- Set to 32 for I standard. Set to 16 for E standard.
\item \lstinline|HAVE_MULDIV| -- Set to TRUE, the MD unit is included. Set to FALSE to exclude MD unit. If set to false, you must not specify the hardware multiply/divide options while compiling software, i.e.\@ multiply and division occur in software.
\item \lstinline|FAST_DIVIDE| -- Set to TRUE to use the radix-4 divider. Set to FALSE to use the radix-2 divider.
\item \lstinline|VECTORED_MTVEC| -- Set to TRUE to provide vectored interrupts. You still have to set bit 0 to 1 in \lstinline|mtvec| CSR. You can still use direct mode. Set to FALSE to only use direct interrupts.
\item \lstinline|MSTATUS_MIE_DISABLES_INTERRUPTS| -- Set to TRUE to only disable interrupts when \lstinline|mstatus.MIE| is 0. Set to FALSE to disable all traps (so including exceptions and when \lstinline|mstatus.MIE| is 0).
\item \lstinline|HAVE_BOOTLOADER_ROM| -- Set to TRUE to provide the bootloader ROM. The PC is set to the start of the bootloader. Set to FALSE to disable the bootloader ROM. The PC is set to the start of the ROM. Disabling the bootloader reduces the RAM block count considerably.
\item \lstinline|HAVE_REGISTERS_IN_RAM| -- Set to TRUE to place the registers in onboard RAM blocks. This lowers the ALM count drastically, but may have an impact on the system frequency. Set to FALSE to place the registers in ALM flipflops.
\end{itemize}

\subsection{Pin assignments}
The pin assignments for the DE0-CV board are as follows (Table~\ref{tab:pins}). Note that not all signals are assigned to a pin, in which case the fitter will assign a suitable pin.

\begin{longtable}{lll}
\caption{Pin assignments for the DE0-CV board.}
\label{tab:pins}\\
\toprule
\textbf{Signal} & \textbf{Pin Name} & \textbf{Board name, comments} \\
\midrule
\endfirsthead
\multicolumn{3}{c}%
{\textit{Continued from previous page}} \\
\toprule
\textbf{Signal} & \textbf{Pin Name} & \textbf{Board name, comments} \\
\midrule
\endhead
\bottomrule
\multicolumn{3}{r}{\textit{Continued on next page}} \\
\endfoot
\bottomrule
\endlastfoot
%\toprule
clk       & M9       & System clock\\
areset    & P22      & FPGA\_RESET, active low reset\\
uart1rxd  & N19      & GPIO\_0\_D15, UART1 receive \\
uart1txd  & P19      & GPIO\_0\_D17, UART1 transmit  \\
pina[31]  & $-$      & Fitter assigned \\
pina[30]  & $-$      & Fitter assigned \\
pina[29]  & $-$      & Fitter assigned \\
pina[28]  & $-$      & Fitter assigned \\
pina[27]  & $-$      & Fitter assigned \\
pina[26]  & $-$      & Fitter assigned \\
pina[25]  & $-$      & Fitter assigned \\
pina[24]  & $-$      & Fitter assigned \\
pina[23]  & $-$      & Fitter assigned \\
pina[22]  & $-$      & Fitter assigned \\
pina[21]  & $-$      & Fitter assigned \\
pina[20]  & $-$      & Fitter assigned \\
pina[19]  & $-$      & Fitter assigned \\
pina[18]  & $-$      & Fitter assigned \\
pina[17]  & $-$      & Fitter assigned \\
pina[16]  & $-$      & Fitter assigned \\
pina[15]  & M6       & KEY3\\
pina[14]  & M7       & KEY2\\
pina[13]  & W9       & KEY1\\
pina[12]  & U7       & KEY0\\
pina[11]  & $-$      & Fitter assigned \\
pina[10]  & $-$      & Fitter assigned \\
pina[9]   & AB12     & SW9 \\
pina[8]   & AB13     & SW8 \\
pina[7]   & AA13     & SW7 \\
pina[6]   & AA14     & SW6 \\
pina[5]   & AB15     & SW5 \\
pina[4]   & AA15     & SW4 \\
pina[3]   & T12      & SW3 \\
pina[2]   & T13      & SW2 \\
pina[1]   & V13      & SW1 \\
pina[0]   & U13      & SW0 \\
pouta[31] & $-$      & Fitter assigned \\
pouta[30] & U22      & HEX16 \\
pouta[29] & AA17     & HEX15 \\
pouta[28] & AB18     & HEX14 \\
pouta[27] & AA18     & HEX13 \\
pouta[26] & AA19     & HEX12 \\
pouta[25] & AB20     & HEX11 \\
pouta[24] & AA29     & HEX10 \\
pouta[23] & $-$      & Fitter assigned \\
pouta[22] & AA22     & HEX06 \\
pouta[21] & Y21      & HEX05 \\
pouta[20] & Y22      & HEX04 \\
pouta[19] & W21      & HEX03 \\
pouta[18] & W22      & HEX02 \\
pouta[17] & V21      & HEX01 \\
pouta[16] & U21      & HEX00 \\
pouta[15] & T17      & GPIO\_0\_D34, software NSS \\
pouta[14] & C11      & SDDAT3, SPI2 software NSS \\
pouta[13] & $-$      & Fitter assigned \\
pouta[12] & $-$      & Fitter assigned \\
pouta[11] & $-$      & Fitter assigned \\
pouta[10] & $-$      & Fitter assigned \\
pouta[9]  & L1       & LEDR9 \\
pouta[8]  & L2       & LEDR8 \\
pouta[7]  & U1       & LEDR7 \\
pouta[6]  & U2       & LEDR6 \\
pouta[5]  & N1       & LEDR5 \\
pouta[4]  & N2       & LEDR4 \\
pouta[3]  & Y3       & LEDR3 \\
pouta[2]  & W2       & LEDR2 \\
pouta[1]  & AA1      & LEDR1 \\
pouta[0]  & AA2      & LEDR0 \\
timer2oct & N21      & GPIO\_0\_D10, output compare T \\
timer2oca & R21      & GPIO\_0\_D12, output compare/PWM A \\
timer2ocb & N20      & GPIO\_0\_D14, output compare/PWM B \\
timer2occ & M22      & GPIO\_0\_D16, output compare/PWM C \\
spi1sck   & K19      & GPIO\_0\_D26, SPI1 clock \\
spi1mosi  & R16      & GPIO\_0\_D28, SPI1 MOSI \\
spi1miso  & R16      & GPIO\_0\_D30, SPI1 MISO \\
spi1nss   & T19      & GPIO\_0\_D32, SPI1 hardware NSS \\
spi2sck   & H11      & SDCLOCK, SPI2 clock \\
spi2mosi  & B11      & SDCMD, SPI2 MOSI \\
spi2miso  & K9       & SDDAT0, SPI2 MISO \\
i2c1scl   & T18      & GPIO\_0\_D33, I2C1 SCL \\
i2c1sda   & T15      & GPIO\_0\_D35, I2C1 SDA
\end{longtable}

\subsection{Simulation}
The designs can be simulated fully, using QuestaSim Intel Starter or ModelSim Intel Starter. You need a (free) license for QuestaSim. During simulation, all essential signals can be viewed, as is the RAM. The RAM is viewed as 32-bit entries, so we need to do some manual calculations to correctly find byte, half word and word accesses. Simulation can be started from Quartus. Please note that the bootloader must be disabled for normal program start up. 

\section{Cloning the RISC-V project}
\label{sec:cloning}
Now we have to clone the RISC-V project. It incorporates the full Quartus Prime Lite project with the processor written in VHDL. It also incorporates some simple C program examples and a taylor-made program to convert a RISC-V executable to a VHDL table suitable for the ROM. Create a working directory (and change to that directory) and issue the command:

\begin{lstlisting}[language=]
git clone https:/github.com/jesseopdenbrouw/riscv-minimal
\end{lstlisting}

In the created directory, you will see the following directories:

\lstinline|sw| -- Sample software programs, linker script, library and startup files \\
\lstinline|docs| -- Documentation \\
\lstinline|rtl| -- the VHDL description(s) \\
%\lstinline|olc| -- yes, really old files for backup \\
%\lstinline|retired| -- Descriptions that are not used anymore

Change directory to \lstinline|sw|. Make sure the RISC-V C compiler is available (see Section~\ref{sec:ccompiler}) and is in your path environment variable. Now enter the command \lstinline|make|. It will compile all programs and the support programs \lstinline|srec2vhdl| and \lstinline|upload|. To clean up the programs, issue the command \lstinline|make clean|.

If you want, you can compile the processor with the standard program incorporated, which is by default, flashing onboard leds and writing the current time since last reset via UART1 at 115200 bps. Start your Quartus Prime Lite software and open the project in the \lstinline|rtl| directory. Now start a build by clicking on the play-symbol. It should compile a standard setting (this takes a long time). When finished, you can download the FPGA contents to the DE0-CV board.

To test one of the programs, change directory to one of the directories in \lstinline|sw| and copy the file with \lstinline|.vhd| extension to the directory containing the VHDL description under the name \lstinline|processor_common_rom.vhd|.
Now start Quartus and start the compilation. After a successful compilation, you can program the Cyclone V on a DE0-CV board.

The design is targeted for a clock speed of 80\,MHz. Depending on how ``good'' the device is fabricated, higher clock speeds may be obtained. With one device, we could speed up the clock to 152\,MHz.

Compilation of the hardware design is independent of the size of the software program. Several design goals may be selected, such as highest clock speed, minimum power or minimum area. Depending on the compilation settings, compilation time may decrease or increase.


\section{Setting up the GNU C compiler for \textit{this} RISC-V}
\label{sec:ccompiler}
The processor can run C and C++ programs that are compiled using the GNU C/C++ compiler for RISC-V. Besides that, a separate linker script and startup file are needed to setup the compiled code. It is possible to set up the C library for multiple RISC-V architecture versions and select a version during compilation. Building the C/C++ compiler (from Linux) is straightforward:

\begin{enumerate}
\item You need a current GNU C/C++ compiler installed or your Linux box. You also need all essential building tools:
\begin{lstlisting}[language=]
apt install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev
\end{lstlisting}
\item You need the texinfo package. On Ubuntu et al.\@ issue
\begin{lstlisting}[language=]
apt install texinfo
\end{lstlisting}
\item In your home directory, enter the command
\begin{lstlisting}[language=]
git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
\end{lstlisting}
\item Wait for the cloning to end (takes a long time, about 30 minutes on a Zbook G5 2020 with a 10 MB/s internet connection)
\item Change to the directory with
\begin{lstlisting}[language=]
cd riscv-gnu-toolchain
\end{lstlisting}
\item Make the \lstinline|build| directory with:
\begin{lstlisting}[language=]
mkdir build; cd build
\end{lstlisting}
\item Check the current configuration with
\begin{lstlisting}[language=]
../configure --help | grep abi
\end{lstlisting}
      It should say:
\begin{lstlisting}[language=]
--with-abi=lp64d    Sets the base RISC-V ABI, defaults to lp64d
\end{lstlisting}
The toolchain is currently configured for 64-bit RISC-V. That is not what we want.
\item Enter:
\begin{lstlisting}[language=]
../configure --prefix=/opt/riscv32 --with-arch=rv32im --with-abi=ilp32 --with-multilib-generator="rv32i-ilp32--;rv32e-ilp32e--"
\end{lstlisting}
This will set the default architecture to RV32IM, with options for RV32I and RV32E (reduced registers, without hardware integer multiply/divide), and the ABI to ilp32 and ilp32e (reduced registers). This means that integers, long integers and pointers use 32-bit entities. The destination directory is \lstinline|/opt/riscv32|.

\item Now enter the \lstinline|make| command: \lstinline|sudo make|\\
Here \lstinline|make| has to run with supervisor privilege, because the toolchain is put in \lstinline|/opt/riscv32|. This takes a long time (about 45 minutes on a Zbook G5). At some points the compilation seems to hang, but it is just compiling complicated C-files. By the way, you will see a lot of warnings.
\item Now that the toolchain is setup, we have to put the path into the \lstinline|$PATH| environment variable so enter
\begin{lstlisting}[language=]
export PATH=/opt/riscv32/bin:$PATH
\end{lstlisting}
\item Check if the compiler is available:
\begin{lstlisting}[language=]
riscv32-unknown-elf-gcc -v
\end{lstlisting}
It should say something like:
\begin{lstlisting}[language=]
Using built-in specs.
COLLECT_GCC=riscv32-unknown-elf-gcc
COLLECT_LTO_WRAPPER=/opt/riscv32/libexec/gcc/riscv32-unknown-elf/12.1.0/lto-wrapper
Target: riscv32-unknown-elf
Configured with: /home/jesse/riscv-gnu-toolchain/build/../gcc/configure --target=riscv32-unknown-elf --prefix=/opt/riscv32 --disable-shared --disable-threads --enable-languages=c,c++ --with-pkgversion=g1ea978e3066 --with-system-zlib --enable-tls --with-newlib --with-sysroot=/opt/riscv32/riscv32-unknown-elf --with-native-system-header-dir=/include --disable-libmudflap --disable-libssp --disable-libquadmath --disable-libgomp --disable-nls --disable-tm-clone-registry --src=/home/jesse/riscv-gnu-toolchain/gcc --enable-multilib --with-multilib-generator='rv32i-ilp32--;rv32e-ilp32e--' --with-abi=ilp32 --with-arch=rv32im --with-tune=rocket --with-isa-spec=2.2 'CFLAGS_FOR_TARGET=-Os   -mcmodel=medlow' 'CXXFLAGS_FOR_TARGET=-Os   -mcmodel=medlow'
Thread model: single
Supported LTO compression algorithms: zlib
gcc version 12.1.0 (g1ea978e3066) 
\end{lstlisting}
\end{enumerate}

\subsection{Register subset}
It is possible to compile the toolchain to only use register \texttt{x0} to \texttt{x15}. This is called the RISC-V E extension. As a positive side effect, the register file can be cut down from 32 registers to 16 registers, saving 512 memory element. This will lower the ALM (cell) count and possible speed up the device. A negative side effect is that the pressure on register allocation is higher, possibly increasing instruction count when saving registers on the stack.

Using the above recipe, the toolchain is set up for both RV32I and RV32E (without hardware integer multiply/divide). You need the specify the architecture and ABI during compile time of the RISC-V programs.

Now compile a C program with:

\begin{lstlisting}[language=]
riscv32-unknown-elf-gcc -O2 -g -o flash flash.c -Wall -T ../ldfiles/riscv.ld -march=rv32e -mabi=ilp32e -nostartfiles --specs=nano.specs ../crt/startup.c
\end{lstlisting}

Make sure to use \lstinline|-march=rv32e| and \lstinline|-mabi=ilp32e|.


\section{Compiling a C program by hand}
We tested a large amount of programs with and without trap handling. We tested all I/O. We did test the use of the C library (\lstinline|malloc| et al, floats and double calculation, some trigonometry functions from the mathematical library), but more tests are needed.

Compiling a program requires the following steps:

\begin{itemize}
\item In the program directory \lstinline|CODE|, create a new directory and change to that directory.
\item Create a C program file, we assume \lstinline|flash.c|.
\item Now issue the command:
\begin{lstlisting}[language=]
riscv32-unknown-elf-gcc -O2 -g -o flash flash.c -Wall -T ../ldfiles/riscv.ld -march=rv32i -nostartfiles --specs=nano.specs ../crt/startup.c
\end{lstlisting}
We supply our own linker file (\lstinline|-T ../ldfiles/riscv.ld|) and we supply our own startup file (\lstinline|../crt/startup.c|). Make sure to use \lstinline|-nostartupfiles| otherwise the default startup file will be linked and errors will report. There a four startup files:
\begin{itemize}
\item \lstinline|empty.S| -- Empty startup file only providing the entry symbol. Can be used with assembler programs. Written in assember.
\item \lstinline|minmal.S| -- Provides the entry symbol, loads the global pointer and stack pointer. Can be used with assembler programs. Written in assembler.
\item \lstinline|startup.S| -- Provides the entry symbol, loads the global pointer and stack pointer and calls \lstinline|main|. On return of \lstinline|main|, it waits in an endless loop. Can be used with minimalistic C programs that do not need global variable initialization and BSS. Written in assembler.
\item \lstinline|startup.c| -- Full support for C programs. Can be used with the standard C library and the mathematical library. Written in C and uses a few assembler instructions.
\end{itemize}
\item Next issue the command:
\begin{lstlisting}[language=]
riscv32-unknown-elf-objcopy -O srec flash flash.srec
\end{lstlisting}
This will create an S-record file in Motorola hex-format.
\item Next issue the command:
\begin{lstlisting}[language=]
../bin/srec2vhdl -wf flash.srec flash.vhd
\end{lstlisting}
This will create a VHDL file with the ROM encoded as 32-bit Little Endian quantities. Note: the taylor-made \lstinline|srec2vhdl| has to be compiled before. See Section~\ref{sec:cloning}.
\item If the bootloader is disabled: issue the command:
\begin{lstlisting}[language=]
cp flash.vhd ../../HARDWARE/riscv-pipe3-csr-md-lic.bootloader/processor_common_rom.vhd
\end{lstlisting}
This will copy the VHDL file to the RISC-V processor ROM file.
\item Now start the compilation of the VHDL code in Quartus Prime Lite and program the compiled file. This file has the extension \lstinline|.sof|. See Figures~\ref{quartus1} to~\ref{programmer}.
\item If the bootloader is enabled: reset the board to start the bootloader. Then start uploading the S-record file with:
\begin{lstlisting}[language=]
../bin/upload -v flash.srec
\end{lstlisting}
This will upload the file \lstinline|flash.srec| to the board. See also Section~\ref{sec:bootloader}.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.85\textwidth]{quartus1}
\caption{Image of the Quartus project (1).}
\label{quartus1}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.85\textwidth]{quartus2}
\caption{Image of the Quartus project (2).}
\label{quartus2}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.85\textwidth]{programmer}
\caption{Image of the programmer.}
\label{programmer}
\end{figure}

\end{itemize}

\section{Implemented system calls}
The \lstinline|sbrk| system call, used for allocating RAM memory, is implemented. Note that there is a limited amount of RAM. Note that \lstinline|sbrk| is not called by the user. Use \lstinline|malloc| et al.

The \lstinline|gettimeofday| system call is implemented. It returns the seconds and microseconds since the last reset of the processor. You need to call the \lstinline|gettimeofday| C function for proper handling. %Works with the \lstinline|clock| C library function.

The \lstinline|times| system call is implemented, but only for non-trap system calls. When using trapped systems calls (using ECALL), \lstinline|gettimeofday| is used.

The \lstinline|read| and \lstinline|write| system calls are implemented but in turn they call the userland functions \lstinline|__io_getchar| and \lstinline|__io_putchar| functions to read or write a character. Normal use is for the latter two to transmit or receive via UART1. When implemented, \lstinline|printf| and \lstinline|scanf| can be used.

Other system calls return an error because they cannot fulfill the requested operation, such as \lstinline|open|. Note that some system calls are in fact not implemented and return undetermined behavior. 

Note: when using traps, the system calls are handled by a trap handler (by using ECALL). This is the default behavior of the tool chain. When not using traps, the system calls are rerouted to functions in a library. You need to set up your software properly, in essence provide functions that override the standard C library functions. See the software examples.

\section{Using trap handlers in software}
We provide (see software examples \lstinline|interrupt_direct| and \lstinline|interrupt_vectored|) a basic implementation of trap handlers. In direct mode, the \lstinline|universal_handler| handles all traps (interrupts and exceptions). The entry point (the address loaded in the \lstinline|mtvec| CSR) must be set in the \lstinline|main| function on a 4-byte boundary, as is enabling traps. In vectored mode, interrupts are redirected to their own handlers via a jump table. The start address of the jump table must be set in the \lstinline|main| function on a 4-byte boundary AND bit 0 must be set to 1, and traps must be enabled. The first entry of the jump table points the universal handler that only handles exceptions. The external timer has its own handler called \lstinline|external_timer_handler|. I2C1 has its own handler for transmit and receive complete interrupts, which is only one handler. The handler is called \lstinline|i2c1_handler|. TIMER1 has its own handler called \lstinline|timer1_handler|. TIMER2 has its own handler called \lstinline|timer2_handler|. Note that there is only one handler for all four interrupt requests. SPI1 has it own handler called \lstinline|spi1_handler|. UART1 has its own handler called \lstinline|uart1_handler|. This handler is used for both receive and transmit interrupts. Note that negating the interrupt request must be done by software in the respective handlers. The interrupt requests are \emph{not} negated by hardware. Note: the external timer interrupt has to be enabled by writing a 1 to \lstinline|mie.MTIE|. Both software examples implement all available interrupts: system timer, SPI1, I2C1, TIMER2, UART1 and TIMER1. SPI2 doesn't have interrupts.

\section{Software programs}
In de \lstinline|sw| directory, there are a number of software programs available. First, the common files:

\begin{itemize}
\item \lstinline|ldfiles| -- contains the linker scripts. There are three scripts:
\begin{itemize}
\item \lstinline|riscv.ld| -- default linker script: ROM = 64 kB, RAM = 32 kB, I/O = 16 kB.
\item \lstinline|riscv-largerom.ld| -- default linker script: ROM = 128 kB, RAM = 32 kB, I/O = 16 kB.
\item \lstinline|riscv-big.ld| -- default linker script: ROM = 128 kB, RAM = 64 kB, I/O = 16 kB.
\end{itemize}
\item \lstinline|crt| -- contains the startup files.
\item \lstinline|bin| -- contains the binaries of \lstinline|srec2vhdl| and \lstinline|upload|.
\item \lstinline|include| -- contains the header files for the design. Use \lstinline|#include <thuasrv32.h>| in programs.
\item \lstinline|lib| -- contains the libraries for the design. Link against\lstinline|libthuasrv32.a|.
\end{itemize}

Some examples are to be used in de simulator only, mainly to test functionality on clock cycle accuracy. Some examples work on the DE0-CV board, but without testing traps. Two examples work on the board and use traps.

\begin{itemize}
\item \lstinline|add64| -- simple 64-bit addition. For use in the simulator.
\item \lstinline|assembler| -- a simple assembler program. For use in the simulator.
\item \lstinline|basel_problem| -- a program that calculates the sum of the inverses of the squares of natural numbers, up to 1000. For use in the simulator. Used to test the divider.
\item \lstinline|bootloader| -- the bootloader program, placed in the bootloader ROM. It has separate startup and linker files. Uses UART1. Works on the board.
\item \lstinline|clock| -- a simple clock using the CSR MTIME and MTIMEH registers to fetch the time since last reset. Uses UART1. Works on the board.
\item \lstinline|double| -- some floating point double computations. For simulation.
\item \lstinline|exp| -- calculates Euler's number e. For simulation.
\item \lstinline|fatfs| -- implementation of FATFS\footnote{\url{http://elm-chan.org/fsw/ff/00index_e.html}}, supports read/write, long filename, codepage 437 (US). FAT16, FAT32 supported. exFAT not tested. Works on the board.
\item \lstinline|flash| -- flash the DE0-CV board leds, works on the board.
\item \lstinline|float| -- some floating point float computations. For simulation.
\item \lstinline|global| -- test for globals and local statics with initialization. For simulation
\item \lstinline|hex_display| -- program that reads 8 switches from the board and display them as a 2-digit hexadecimal value on the 7-segment display. Works on the board. Note that on the DE0-CV board, the decimal points cannot be used, because they are not connected to FPGA pins.
\item \lstinline|i2c1findslaves| -- program that uses the I2C1 peripheral to find slaves on the I\textsuperscript{2}C bus. Prints out the found slaves addresses on the terminal. Works on the board.
\item \lstinline|i2c1tmp102| -- program that uses the I2C1 peripheral to fetch the temperature data of an TMP102 temperature sensor and displays the raw data on the terminal. Works on the board.
\item \lstinline|interrupt_direct| -- program to test the interrupt handling using direct mode and prints out the elapsed time. Uses UART1. Works on the board.
\item \lstinline|interrupt_vectored| -- program to test the interrupt handling using vectored mode.and prints out the elapsed time. Uses UART1. Works on the board.
\item \lstinline|interval| -- program that uses the \lstinline|clock| C library function to time 5 seconds since last read. Uses UART1. Works on the board.
\item \lstinline|ioadd| -- adds the lower 5 switches to the upper 5 switches and displays the result on the leds. Tests addition, shifting and I/O. Works on the board.
\item \lstinline|linked\_list| -- example on how to use linked lists. This program soups up all available dynamic RAM but does not penetrate the reserved stack space. Uses UART1. Works on the board.
\item \lstinline|malloc| -- example to test \lstinline|malloc| and friends. Works. Used in simulations.
\item \lstinline|monitor| -- simple monitor program. Works on the board. Uses strings, UART1, RAM, ROM, I/O and \lstinline|sprintf| (and therefore \lstinline|malloc| et al.).
\item \lstinline|mult| -- integer multiplication with the C library. Set to the E extension with no hardware multiply/divide support. For simulations.
\item \lstinline|qsort| -- sorts an integer array using the \lstinline|qsort| C library function. Works in simulation.
\item \lstinline|riemann_left| -- calculates the Riemann Left Sum of $\sin^2 x$ from $0$ to $2\pi$. For use in the simulator. The  result must be $\pi$.
\item \lstinline|shift| -- shifts. For use in simulations.
\item \lstinline|spi1readeeprom| -- using the SPI1 peripheral to read out 16 bytes of the 25AA010A EEPROM slave, one byte at the time, using hardware Slave Select. Uses UART1. Works on the board.
\item \lstinline|spi1softnss| -- as \lstinline|spi1readeeprom|, using software Slave Select.
\item \lstinline|spi1speed| -- using the SPI1 peripheral to read out (full speed) 16 bytes of the 25AA010A EEPROM slave, using hardware Slave Select. Uses UART1. Works on the board.
\item \lstinline|spi1writeeeprom| -- using the SPI1 peripheral to write and read out (full speed) the 25AA010A EEPROM slave, using software Slave Select. Uses UART1. Works on the board.
\item \lstinline|sprintf| -- prints integers, floats/doubles to a string. This is a big binary. For simulations.
\item \lstinline|string| -- some string functions. For simulations.
\item \lstinline|testio| -- simple program that copies the input (switches) to the output (leds). Works on the board.
\item \lstinline|trig| -- some float trigonometry functions for float and double. Prints results to UART1. This is a big binary.
\item \lstinline|upload| -- a Linux/PC program to upload an S-record file using the bootloader.
\item \lstinline|uart_test| -- simple UART1 program. Works on the board.
\item \lstinline|uart_cpp|-- simple C++ UART program. Makes use of a singleton design pattern. Uses a lot of ROM. Works on the board.
\item \lstinline|uart_printf| -- simple program that prints an integer, a pointer, a float and a double to the terminal using \lstinline|printf|, this is a big binary. Works on the board.
\item \lstinline|uart_sprintf| -- simple program that prints an integer, a pointer, a float and a double to the terminal, this is a big binary. Works on the board.
\end{itemize} 

Note: we use a lot of the \lstinline|volatile| keyword to emit the variables to RAM for easy inspection in the simulator. You will see compiler warnings from C library functions.

Note that the floating point programs loads (huge) functions from the C library and possibly creates a binary that is too large to fit in the ROM. In that case, the linker will issue an error and does not build the binary. You have to update the data sizes in the VHDL description and update the linker script with suitable data sizes.

When using floats and doubles in \lstinline|sprintf|/\lstinline|printf|, you need to supply the linker with the \lstinline|-u _printf_float| option. When using floats and doubles in \lstinline|sscanf|/\lstinline|scanf|, you need to supply the linker with the \lstinline|-u _scanf_float| option. Also, using \lstinline|printf| and \lstinline|scanf| create big binaries.

\subsection{srec2vhdl}
This is a homebrew utility to convert a Motorola S-record file into a VHDL file suitable for inclusion of the processor. The program is called with:

\begin{lstlisting}[language=c]
srec2vhdl [-fbwhqv0] [-i <arg>] inputfile [outputfile]
\end{lstlisting}

\lstinline|inputfile| is the S-record file, created by the \lstinline|objdump| program. \lstinline|outputfile| is the VHDL output file. When omitted, \lstinline|stdout| is used. There are a number of options:

\begin{itemize}
\item \lstinline|-f| makes a full output that directly can be used. If not used, only the ROM table contents itself is produced.
\item \lstinline|-w| ROM contents is in words (32 bits).
\item \lstinline|-h| ROM contents is in half words (16 bits).
\item \lstinline|-b| ROM contents is in bytes (8 bits).
\item \lstinline|-v| Verbose output.
\item \lstinline|-0| Output unused ROM data as 0 instead of don't care.
\item \lstinline|-q| Quiet output, only error messages are displayed.
\item \lstinline|-i <arg>| indents each line with \lstinline|<arg>| spaces.
\end{itemize}

Note: uninitialized ROM contents are emitted as don't care, except when the \lstinline|-0| option is used. Don't cares are set to 0 by Quartus on default.

%\subsection{Monitor program}
%A simple monitor program is available, see the \lstinline|monitor| directory in software examples. It makes use of UART1. You need a terminal program like Putty and a U(S)ART to USB device for your computer. Currently the following commands are available:
%
%\begin{itemize}
%\item \lstinline|l| -- set Little Endian (default),
%\item \lstinline|b| -- set Big endian.
%\item \lstinline|rw <address>| -- read word at address (4-byte boundary),
%\item \lstinline|rh <address>| -- read half word at address (2-byte boundary),
%\item \lstinline|rb <address>| -- read byte at address,
%\item \lstinline|ww <address> <data>| -- write word at address (4-byte boundary),
%\item \lstinline|wh <address> <data>| -- write half word at address (2-byte boundary),
%\item \lstinline|wb <address> <data>| -- write byte at address,
%\end{itemize}
%
%\lstinline|<address>| and \lstinline|<data>| in hexadecimal and Big Endian format. For ROM and RAM read accesses, best set to Little Endian. For I/O accesses, set Big Endian. Make sure to read and write I/O as words. Note that ROM cannot be written.

\section{Address ranges and memory sizes}
By default, the ROM starts at address 0x00000000 and and has a size of 64 kB (16 k words). The bootloader ROM starts at address 0x10000000 and has a size of 4 kB (1 k words). The Program Counter starts at address 0x10000000. The RAM starts at address 0x20000000 and has a size of 32 kB (8 k words). The stack pointer is set to one address above the last RAM byte, by default at 0x20008000. The I/O starts at address 0xF0000000 and has a size of 16 kB (4 k words).

The ROM, bootloader ROM, RAM and I/O may be moved to another start location. The Program Counter is started at the correct address. The placement of the ROM is in 256 MB intervals, which are the 4 most significant bits of a 32-bit address. The same holds for the RAM and the I/O. To move the ROM, open file \lstinline|processor_common.vhd| and go down to the end of the file. There you will see the following lines:

\begin{lstlisting}[language=VHDL]
    -- The highest nibble (4 bits) of the ROM, bootloader, RAM and I/O
    -- This will set the memories at 256 MB intervals
    constant rom_high_nibble : std_logic_vector(3 downto 0) := x"0";
    constant bootloader_high_nibble : std_logic_vector(3 downto 0) := x"1";
    constant ram_high_nibble : std_logic_vector(3 downto 0) := x"2";
    constant io_high_nibble : std_logic_vector(3 downto 0) := x"F";
\end{lstlisting}

Change the start locations of the memories by changing the constants. Make sure the memories do not overlap. To change the sizes of the memory, look for the lines as shown below:

\begin{lstlisting}[language=VHDL]
    -- The ROM
    -- NOTE: the ROM is word (32 bits) size.
    -- NOTE: data is in Little Endian format (as by the toolchain)
    --       for half word and word entities
    --       Set rom_size_bits as if it were bytes
    --       default is 64 kB data
    constant rom_size_bits : integer := 16;
    constant rom_size : integer := 2**(rom_size_bits-2);
    type rom_type is array(0 to rom_size-1) of data_type;
    -- The contents of the ROM is loaded by processor_common_rom.vhd
    
    -- The bootloader ROM
    -- NOTE: the bootloader ROM is word (32 bits) size.
    -- NOTE: data is in Little Endian format (as by the toolchain)
    --       for half word and word entities
    --       Set bootloader rom_size_bits as if it were bytes
    --       default is 4 kB data
    constant bootloader_size_bits : integer := 12;
    constant bootloader_size : integer := 2**(bootloader_size_bits-2);
    type bootloader_type is array(0 to bootloader_size-1) of data_type;
    -- The contents of the bootloader ROM is loaded by bootloader.vhd
    
    -- The RAM
    -- NOTE: the RAM is 4x byte (8 bits) size, supporting
    --       32-bit Big Endian storage,
    --       so we have to recode to support Little Endian.
    --       Set ram_size_bits as if it were bytes
    -- Default is 32 kB data
    constant ram_size_bits : integer := 15;
    constant ram_size : integer := 2**(ram_size_bits-2);
    -- The type of the RAM block
    type ram_type is array (0 to ram_size-1) of std_logic_vector(7 downto 0);
                        
    -- The I/O
    -- NOTE: the I/O is word (32 bits) size, Big Endian
    --       there is no need to recode the data
    --       The I/O can only handle word size access
    --       Set io_size_bits as if it were bytes
    -- Default 256 bytes data
    constant io_size_bits : integer := 8;
    constant io_size : integer := 2**(io_size_bits-2);
    type io_type is array (0 to io_size-1) of data_type;
\end{lstlisting}

Note that you also have to make changes to the linker script. In the file \lstinline|riscv.ld|, at the top you will find the following lines. Change the origins in accordance with the VHDL description.

\begin{lstlisting}
ENTRY( _start )

MEMORY
{
   ROM (rx)   : ORIGIN = 0x00000000, LENGTH = 64K
   RAM (rw)   : ORIGIN = 0x20000000, LENGTH = 32K
   IO (rw)    : ORIGIN = 0xf0000000, LENGTH = 16K
}
\end{lstlisting}

In this setting, the ROM is 64 kB long and the RAM is 32 kB long. Please note that both ROM and RAM bits may not exceed 3,153,920 bits of onboard RAM. For increased ROM and RAM size, typical values may be 128 kB ROM and 64 kB RAM.

Note that we do not use full address decoding for ROM, RAM and I/O. This means that, for example, the ROM is visible multiple times in the address space. This is called \emph{memory foldback}. For the ROM this is at 64 kB intervals. So the contents of address 0x00000000 is also available at address 0x00010000.

\section{Using the bootloader}
\label{sec:bootloader}
The design incorporates a hard-coded bootloader with an upload and a simple monitor program. The bootloader is placed in a separate ROM starting at address 0x10000000 and has a maximum length of 4 KB (may be extended). The bootloader cannot be overwritten by an upload. The bootloader can be disabled.

\subsection{S-record file}
The S-record standard is invented by Motorola in the 1980's. It consists of formatted lines, called records. Each line can be seen as a record. A record starts with \lstinline|S| followed by a single digit. \lstinline|S0| is used as header record. This record is ignored by the bootloader (skipped). \lstinline|S1|,  \lstinline|S2| and \lstinline|S3| are data record using a 2-byte, 3-byte and 4-byte start address respectively. \lstinline|S4| is reserved and skipped by the bootloader. \lstinline|S5| and \lstinline|S6| are count records and are ignored. \lstinline|S7|, \lstinline|S8| and \lstinline|S9| are termination records with a start address incorporated, with 4-byte, 3-byte and 2-byte address respectively. This start address is used by the bootloader to start the application. Records have a checksum at the end, this checksum is ignored by the bootloader.

\subsection{Startup sequence}
After loading the design in the FPGA, or after resetting the FPGA, the bootloader starts. It presents itself with a welcome string printed via UART1 at default 115200 bps. Then the bootloader waits for about 5 seconds before starting the application at address 0x00000000. During these 5 seconds, at half second intervals, a \lstinline|*| is printed via UART1. At the same time, the 10 red leds on the DE0-CV board are lit and dimmed on half second intervals from left (high led) to right (low led). If a character is received within the five seconds, either a S-record file can be uploaded or the bootloader falls to a simple monitor program.

\subsection{Uploading an S-record file}
A Motorola S-record file can be uploaded with the \lstinline|upload| program found in the \lstinline|CODE| directory. It is tested on Linux, Windows is currently not supported. S-record files for all RISC-V programs are generated as part of the \lstinline|make| process by the RISC-V \lstinline|objcopy| program. The \lstinline|upload| program is invoked with:

\begin{lstlisting}[language=]
upload -d <device> -b <baud> -t <timeout> -s <sleep> -v -j file
\end{lstlisting}

The default device is \lstinline|/dev/ttyUSB0| which is the first plugged-in USB-to-U(S)ART converter. The baudrate may be 9600 bps or 115200 bps (default). Timeout is the time the \lstinline|uplead| program waits for expected data from the bootloader. The time is set in deciseconds (0.1 seconds) intervals. The default value is 10 (1.0 seconds). Sleep is the time the \lstinline|upload| program waits after transmitting a character tor the bootloader in microseconds intervals. The default value is 0. The option \lstinline|-v| turns on verbose mode. The option \lstinline[]|-j| instructs \lstinline|upload| to send a ``start application'' command to the bootloader after the S-record file is uploaded. File must be a valid S-record file.

To upload an S-record file, reset the FPGA or program the FPGA design in the FPGA. Then, within the 5 seconds interval, start the \lstinline|upload| program with options and file name supplied. If the \lstinline|upload| programs manages the contact the bootloader, the S-record file will be uploaded. Depending on the size, uploading may take as short as a few seconds to minutes for a large file. As a rule of thumb, about 2400 file characters per seconds are send (at 115200 bps). Make sure that \emph{no} terminal program (e.g. Putty) is active. If the \lstinline|upload| program cannot contact the bootloader, it exits with an error message. If during sending the records, a response from the bootloader is not read, the \lstinline|upload| exits with an error message. This is mostly due to an open terminal connection. To start the application after the upload, supply the \lstinline|-j| option to the \lstinline|upload| program, otherwise the monitor is started. Before starting the application, UART1 is turned off and the output port is set to 0x00000000 (i.e. all port bits are set to 0).

Using an USB-to-serial adapter can be troublesome, for example when stopping (Ctrl-C) the upload program. There will be characters in the USB buffer and the upload program and the bootloader will be out of sync. Best is to remove the USB-to-serial adapter from the PC and reinsert it again. Then the USB buffer will be empty. During the transmission, the low led of the DE0-CV board will flash rapidly. If not, there is no upload and the USB-to-serial adapter and the DE0-CV board are out of sync.

\subsection{Using the monitor}
If within the 5 seconds grace period a character is received by the bootloader, the bootloader falls to a simple monitor program. The monitor recognized some simple commands. Each command is terminated by an enter key.

\lstinline|r|

Run the program at address 0x00000000.

\lstinline|rw <address>|

Read and print word at address. Address must be on a 4-byte boundary. Data is presented in big endian.

\lstinline|dw <address>|

Dump 16 words from memory to the terminal. Address must be on a 4-byte boundary. After each word, 4 ASCII characters are printed, if printable. If not printable, a dot is printed. Useful for finding strings in memory. Data is presented in big endian.

\lstinline|n|

Dump next 16 words from memory to the terminal, and ASCII characters.

\lstinline|rw <address> <data>|

Write 4-byte data at address. Address must be on a 4-byte boundary. Data must be in big endian.

\lstinline|h|

A simple help menu is presented.

Note: the capabilities of the monitor may be extended.

\subsection{Upload protocol}
Uploading an S-record file uses a simple handshake protocol. The \lstinline|upload| program sends a single exclamation mark (\lstinline|!|). The bootloader responds with an question mark (\lstinline|?|) and a newline (\lstinline|\n|). Now each S-record line is transmitted character by character, including the end-of-line termination character (\lstinline|\r| and/or \lstinline|\n|). After a line is processed, the bootloader responds with a question mark and a newline. After all S-record lines are transmitted, the \lstinline|upload| program either sends a \lstinline|J| to start the application, or a \lstinline|#| to start the monitor.

\subsection{Implications on the hardware design}
The design has a separate ROM that incorporates the bootloader. The original ROM, at address 0x00000000 is extended with a write port, together with the instruction read port and the data read port. In fact, the ROM has become a (program) RAM. Because the Cyclone FPGA ROMs (and RAMs) can only have two ports (out/out or in/out), the original ROM hardware is duplicated (by the synthesizer). This takes up onboard RAM blocks, but very few ALMs (cells). % The speed decrements by a few MHz.

Note that the ROM can only be (over)written with words on a 4-byte boundary.

\section{Future plans (or not) and issues}
Some future plans:

\begin{itemize}
\item We are \emph{not} planning the C standard.
\item The CSR is not conform the standard, but should be.
\item Implement clock stretching and arbitration in the I\textsuperscript{2}C peripheral.
\item Adding input synchronization for SPI1/SPI2 and I2C1 peripherals.
\item Adding Input Capture for TIMER2.
\item Implement an I/O input/output multiplexer for \lstinline|pina| and \lstinline|pouta|. This will enable I/O functions to be multiplexed with normal port I/O.
\item Smaller (in cells) divide unit.
\item Test more functions of the standard and mathematical libraries.
\item It is not possible to print \lstinline|long long| (i.e. 64-bit) using \lstinline|printf| et al. When using the format specifier \lstinline|%lld|, \lstinline|printf| just prints \lstinline|ld|. This due to lack of support in the \lstinline|nano| library.
\item The \lstinline|mtime| (MTIMEH:MTIME) registers are currently read only, but should be writable.
\end{itemize}

\appendix
\section{The I/O at a glance}

The I/O registers are directly addressable or by a struct. See the listing below.

\begin{lstlisting}[language=C,breaklines=false]
/*
 *     io.h - definitions for the I/O of the
 *            THUAS RISC-V processor
 */

#ifndef _IO_H
#define _IO_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>


/* Base address of the I/O */
#define IO_BASE (0xf0000000UL)


/*
 * General purpose I/O
 */
typedef struct {
        volatile uint32_t PIN;
        volatile uint32_t POUT;
} GPIO_struct_t;

#define GPIOA_BASE (IO_BASE+0x00000000UL)
#define GPIOA ((GPIO_struct_t *) GPIOA_BASE)

#define GPIOA_PIN  (*(volatile uint32_t*)(GPIOA_BASE+0x00000000UL))
#define GPIOA_POUT (*(volatile uint32_t*)(GPIOA_BASE+0x00000004UL))


/* UART1 */
typedef struct {
	volatile uint32_t DATA;
	volatile uint32_t BAUD;
	volatile uint32_t CTRL;
	volatile uint32_t STAT;
} UART_struct_t;

#define UART_BASE (IO_BASE+0x00000020UL)
#define UART1 ((UART_struct_t *) UART_BASE)

#define UART1_DATA (*(volatile uint32_t*)(UART_BASE+0x00000000UL))
#define UART1_BAUD (*(volatile uint32_t*)(UART_BASE+0x00000004UL))
#define UART1_CTRL (*(volatile uint32_t*)(UART_BASE+0x00000008UL))
#define UART1_STAT (*(volatile uint32_t*)(UART_BASE+0x0000000cUL))


/*
 * I2C1
*/
typedef struct {
	volatile uint32_t CTRL;
	volatile uint32_t STAT;
	volatile uint32_t DATA;
} I2C_struct_t;

#define I2C_BASE (IO_BASE+0x00000040UL)
#define I2C1 ((I2C_struct_t *) I2C_BASE)

#define I2C1_CTRL (*(volatile uint32_t*)(I2C_BASE+0x00000000UL))
#define I2C1_STAT (*(volatile uint32_t*)(I2C_BASE+0x00000004UL))
#define I2C1_DATA (*(volatile uint32_t*)(I2C_BASE+0x00000008UL))


/*
 * SPI1, SPI2
 */
typedef struct {
	volatile uint32_t CTRL;
	volatile uint32_t STAT;
	volatile uint32_t DATA;
} SPI_struct_t;

#define SPI_BASE (IO_BASE+0x00000060UL)
#define SPI1 ((SPI_struct_t *) SPI_BASE)
#define SPI2 ((SPI_struct_t *) (SPI_BASE + 0x10))

#define SPI1_CTRL (*(volatile uint32_t*)(SPI_BASE+0x00000000UL))
#define SPI1_STAT (*(volatile uint32_t*)(SPI_BASE+0x00000004UL))
#define SPI1_DATA (*(volatile uint32_t*)(SPI_BASE+0x00000008UL))
#define SPI2_CTRL (*(volatile uint32_t*)(SPI_BASE+0x00000010UL))
#define SPI2_STAT (*(volatile uint32_t*)(SPI_BASE+0x00000014UL))
#define SPI2_DATA (*(volatile uint32_t*)(SPI_BASE+0x00000018UL))


/*
 * TIMER1
 */
typedef struct {
	volatile uint32_t CTRL;
	volatile uint32_t STAT;
	volatile uint32_t CNTR;
	volatile uint32_t CMPT;
} TIMER1_struct_t;

#define TIMER1_BASE (IO_BASE+0x00000080UL)
#define TIMER1 ((TIMER1_struct_t *) TIMER1_BASE)

#define TIMER1_CTRL (*(volatile uint32_t*)(TIMER1_BASE+0x00000000UL))
#define TIMER1_STAT (*(volatile uint32_t*)(TIMER1_BASE+0x00000004UL))
#define TIMER1_CNTR (*(volatile uint32_t*)(TIMER1_BASE+0x00000008UL))
#define TIMER1_CMPT (*(volatile uint32_t*)(TIMER1_BASE+0x0000000cUL))


/*
 * TIMER2
 */
typedef struct {
	volatile uint32_t CTRL;
	volatile uint32_t STAT;
	volatile uint32_t CNTR;
	volatile uint32_t CMPT;
	volatile uint32_t PRSC;
	volatile uint32_t CMPA;
	volatile uint32_t CMPB;
	volatile uint32_t CMPC;
} TIMER2_struct_t;

#define TIMER2_BASE (IO_BASE+0x000000a0UL)
#define TIMER2 ((TIMER2_struct_t *) TIMER2_BASE)

#define TIMER2_CTRL (*(volatile uint32_t*)(TIMER2_BASE+0x00000000UL))
#define TIMER2_STAT (*(volatile uint32_t*)(TIMER2_BASE+0x00000004UL))
#define TIMER2_CNTR (*(volatile uint32_t*)(TIMER2_BASE+0x00000008UL))
#define TIMER2_CMPT (*(volatile uint32_t*)(TIMER2_BASE+0x0000000cUL))
#define TIMER2_PRSC (*(volatile uint32_t*)(TIMER2_BASE+0x00000010UL))
#define TIMER2_CMPA (*(volatile uint32_t*)(TIMER2_BASE+0x00000014UL))
#define TIMER2_CMPB (*(volatile uint32_t*)(TIMER2_BASE+0x00000018UL))
#define TIMER2_CMPC (*(volatile uint32_t*)(TIMER2_BASE+0x0000001cUL))


/*
 * RISC-V system timer (in I/O)i
 */
#define TIME (*(volatile uint32_t*)(IO_BASE+0x000000f0UL))
#define TIMEH (*(volatile uint32_t*)(IO_BASE+0x000000f4UL))
#define TIMECMP (*(volatile uint32_t*)(IO_BASE+0x000000f8UL))
#define TIMECMPH (*(volatile uint32_t*)(IO_BASE+0x000000fcUL))

typedef struct {
	volatile uint32_t time;
	volatile uint32_t timeh;
} TIME_struct_t;

typedef struct {
	volatile uint32_t timecmp;
	volatile uint32_t timecmph;
} TIMECMP_struct_t;

#ifdef __cplusplus
}
#endif

#endif
\end{lstlisting}

\section{Port I/O}
The processor is equipped with a single 32-bit input and 32-bit output port. There is no data direction register. This may be changed to using bi-direction port pins. Note that all accesses on the I/O are in Big Endian. This means that bit 31 of the input will be placed in bit 31 of the used variable.

To set the outputs, use:

\begin{lstlisting}[language=C]
uint32_t output = 0xff00ff00;

GPIOA->POUT = output;
\end{lstlisting}

Modifying bits of a I/O register must be done by a read-modify-write cycle. This is \emph{not} atomically handled and can interfere with interrupts! For example, to set bit 2 of POUT, use:

\begin{lstlisting}[language=C]
GPIOA->POUT |= 0x04;
\end{lstlisting}

\section{UART1 Code}

UART1 can send and receive data with one start bit, 7/8/9 data bits, N/E/O parity and 1 or 2 stop bits. Transmission is tested with a baud rate of 9600 bps, 115200 bps and 230400 bps. Send and receive speeds are equal as is the number of data bits, parity and the number of stop bits. There are no auxiliary control signals (e.g. RTS and CTS). There is no embedded FIFO to buffer incoming data. UART1 is programmable using I/O registers, see Appendix~\ref{sec:ioregisters}. Note that using a system frequency of 50 MHz, the baud rate cannot be lower than 763 bps, because the baud rate generator uses a 16-bit register.

To initialize UART1, use the code in the listing below:

\begin{lstlisting}[language=C]
/* Frequency of the DE0-CV board */
#define F_CPU (50000000UL)
/* Transmission speed */
#define BAUD_RATE (9600UL)

/* Initialize the Baud Rate Generator */
void UART1_init(void)
{
    /* Set baud rate generator */
    UART1->BAUD = F_CPU/BAUD_RATE-1;
}
\end{lstlisting}

To send a single character with waiting, use the code in the listing below:

\begin{lstlisting}[language=C]
/* Send one character over UART1 */
void uart1_putc(int ch)
{
    /* Transmit data */
    UART1->DATA = (uint8_t) ch;
            
    /* Wait for transmission end */
    while ((UART1->STAT & 0x10) == 0);
}
\end{lstlisting}

To send a null-terminated string, use the code in the listing below:

\begin{lstlisting}[language=C]
/* Send a null-terminated string over UART1 */
void uart1_puts(char *s)
{
    if (s == NULL)
    {
        return;
    }

    while (*s != '\0')
    {
        uart1_putc(*s++);
    }
}
\end{lstlisting}

To wait for a character reception, use the code in the listing below:

\begin{lstlisting}[language=C]
/* Get one character from UART1 in
 * blocking mode */
int uart1_getc(void)
{
    /* Wait for received character */
    while ((UART1->STAT & 0x04) == 0);

    /* Return 8-bit data */
    return UART1->DATA & 0x000000ff;
}
\end{lstlisting}

To receive a string from UART1, including some simple line editing, use the code in the listing below:

\begin{lstlisting}[language=C]
/* Gets a string terminated by a newline character from UART1
 * The newline character is not part of the returned string.
 * The string is null-terminated.
 * A maximum of size-1 characters are read.
 * Some simple line handling is implemented */
int uart1_gets(char buffer[], int size)
{
	int index = 0;
	char chr;

	while (1) {
		chr = uart1_getc();
		switch (chr) {
			case '\n':
			case '\r':	buffer[index] = '\0';
					uart1_puts("\r\n");
					return index;
					break;
			/* Backspace key */
			case 0x7f:
			case '\b':	if (index>0) {
						uart1_putc(0x7f);
						index--;
					} else {
						uart1_putc('\a');
					}
					break;
			/* control-U */
			case 21:	while (index>0) {
						uart1_putc(0x7f);
						index--;
					}
					break;
			/* control-C */
			case 0x03:  	uart1_puts("<break>\r\n");
					index=0;
					break;
			default:	if (index<size-1) {
						if (chr>0x1f && chr<0x7f) {
							buffer[index] = chr;
							index++;
							uart1_putc(chr);
						}
					} else {
						uart1_putc('\a');
					}
					break;
		}
	}
	return index;
}
\end{lstlisting}

When printing a C newline, you have to use:

\begin{lstlisting}[language=C]
uart1_puts("\r\n");
\end{lstlisting}

This will set the cursor to the beginning of a new line. Here, \lstinline|\r| returns the cursor to the beginning of the current line and \lstinline|\n| advances the cursor to the next line. Some terminal emulation programs can be instructed to move to the beginning of a new line with only \lstinline|\n|.

For working with the UART on board of the processor, you need an USB-to-U(S)ART device with TTL (3.3 V) converter. An example is shown in Figure~\ref{fig:usb-usart-ttl}.

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.1]{usb-usart-ttl}
\caption{An USB-to-U(S)ART converter. Make sure that the voltages do not exceed 3.3 V.}
\label{fig:usb-usart-ttl}
\end{figure}


\section{I\textsuperscript{2}C code}
The baud rate prescaler must be loaded with the number of system clock cycles for \textbf{one-half} bit time for Standard mode, and \textbf{one-third} bit time for Fast mode. Note that the prescaler is in the CTRL register and must be preserved:

\begin{lstlisting}[caption=]
/* Standard mode, exact number */
#define TRAN_SPEED ((F_CPU/2UL/100000UL)-1)
I2C1->CTRL = TRAN_SPEED << 16;
/* Fast mode, round up to integer */
#define TRAN_SPEED (((F_CPU/3UL/400000UL)-1)+1)
I2C1->CTRL = (TRAN_SPEED << 16) | (1 << 2);
\end{lstlisting} 

Note that for a 50\,MHz system clock frequency, an exact count is achieved for Standard Mode (250), but not for Fast mode (41.6667), so the rounding must be up.

To send a startbit, before an address byte is send, use:

\begin{lstlisting}[caption=]
I2C1->CTRL |= (1 << 9);
\end{lstlisting} 

To send an address byte, with read-write bit, left-shift the address by 1 and add the read/write bit:

\begin{lstlisting}[caption=]
I2C1->DATA = (ADDR << 1) | RWBIT;
while ((I2C1->STAT & 0x08) == 0x00);
\end{lstlisting} 

To check for acknowledge, use:

\begin{lstlisting}[caption=]
if (I2C1->STAT & (1 << 5)) {
    uart1_puts("ACK failed!\r\n");
} else {
    uart1_puts("ACK ok\r\n");
}
\end{lstlisting} 

To send a byte and wait for transmission complete, use:

\begin{lstlisting}[caption=]
I2C1->DATA = some_data;
while ((I2C1->STAT & 0x08) == 0x00);
\end{lstlisting} 

After the address is transmitted, and the read-write bit is set to write, the controller changes to receive mode. It will then constantly send clock pulses. To stop transmission, the send-stopbit must be activated on the last byte to receive.

\begin{lstlisting}[caption=]
/* Controller is receiving */
while ((I2C1->STAT & 0x10) == 0x00);
some_variable = I2C1->DATA;

/* Set STOP generation */
I2C1->CTRL |= (1 << 8);
/* Wait for data transmission completed */
while ((I2C1->STAT & 0x10) == 0x00);
some_variable = I2C1->DATA;
\end{lstlisting} 

To check if a target is listening on a address, send address (with read or write) and send a startbit and stopbit:

\begin{lstlisting}[caption=]
/* Set START and STOP generation */
I2C1->CTRL |= (1 << 9) | (1 << 8);

/* Write address + write bit */
I2C1->DATA = (some_address << 1) | 0;
\end{lstlisting} 


\section{TIMER1 code}
Based on a frequency of 50$\,$MHz, the following code will set TIMER1 interrupt on 0,5 s intervals:

\begin{lstlisting}[language=C]
/* Activate TIMER1 with a cycle of 2 Hz */
/* for a 50 MHz clock. Use interrupt. */
TIMER1->CMPT = 24999999;
/* Bit 0 = enable, bit 4 is interrupt enable */
TIMER1->CTRL = (1<<4)|(1<<0);
\end{lstlisting}

\section{The external \texttt{time} registers}
The \lstinline|time| registers (MTIME, MTIMEH, MTIMEMCP and MTIMECMPH) can be accessed via the I/O and are therefore memory mapped. These registers are shadowed by the CSR. The following code reads in the current time and increments the compare registers with a certain \emph{delta}. Whenever TIMEH:TIME is greater than or equal to TIMEH:TIME, an interrupt request is asserted. Negating the interrupt request is accomplished by writing a value greater than the time registers to the compare registers.

\begin{lstlisting}[language=C]
void external_timer_handler(void)
{
    register uint32_t time;
    register uint32_t timeh;

    /* Fetch current time */
    do {
        timeh = MTIMEH;
        time  = MTIME;
    } while (timeh != MTIMEH);

    /* Fetch current time */
    register uint64_t cur_time = ((uint64_t)timeh << 32) | (uint64_t)time;

    /* Add delta */
    cur_time += external_timer_delta;
    /* Set TIMECMP to maximum */
    MTIMECMPH = -1;
    MTIMECMP = -1;
    /* Store new TIMECMP */
    MTIMECMP = (uint32_t)(cur_time & 0xffffffff);
    MTIMECMPH = (uint32_t)(cur_time>>32);
    /* Flip output bit 1 (led) */
    GPIOA->POUT ^= 0x2;
}
\end{lstlisting}

Normally, this code is placed in the interrupt handler. These registers are read-only shadowed to the CSR time registers.

\section{I/O registers}
\label{sec:ioregisters}
This is a list of currently supported I/O addresses. 
The default start address is 0xF0000000. The offset is given in bytes. Note that the I/O can only be accesses on 4-byte boundaries and on word size accesses.

\subsection{GPIOA -- General Purpose I/O}

\begin{register}{H}{Port A input register GPIOA\_PIN}{0x00}%
\label{pinx}%
\regfield{PIN}{32}{0}{{0}}% READ_ONLY
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.6\textwidth]\begin{reglist}[000000000]
\itemsep-1.5ex
\item[Note:] This I/O register can only be read.
\end{reglist}\end{regdesc}

\begin{register}{H}{Port A output register GPIOA\_POUT}{0x04}%
\label{poutx}%
\regfield{POUT}{32}{0}{{0}}
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.6\textwidth]\begin{reglist}[000000000]
\itemsep-1.5ex
\item[Write] The data is written to the output pins.
\item[Read] The last entered data is read back.
\end{reglist}\end{regdesc}

\subsection{UART1 -- Universal Asynchronous Receiver/Transmitter}

\begin{register}{H}{UART1 data register UART1\_DATA}{0x20}
\label{uart1data}
\regfield{Reserved}{22}{9}{{0}}%
\regfield{Data}{9}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.6\textwidth]\begin{reglist}[000000000]
\itemsep-1.5ex
\item[Write] The data is written to an internal buffer and transmitted.
\item[Read] The last received data is read.
\end{reglist}\end{regdesc}
\hspace*{2cm}Size depends on the Size field in the UART1 Control Register.

\begin{register}{H}{UART1 baud rate register UART1\_BAUD}{0x24}
\label{uart1baud}
\regfield{Rerserved}{16}{16}{{0}}%
\regfield{Prescaler}{16}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.6\textwidth]\begin{reglist}[000000000]
\itemsep-1.5ex
\item[Prescaler] Baud rate = $\dfrac{f_{system}}{\textrm{prescaler}+1}$
\end{reglist}\end{regdesc}

\begin{register}{H}{UART1 control register UART1\_CTRL}{0x28}
\label{uart1ctrl}
\regfield{Reserved}{24}{8}{{0}}%
\regfield{TCIE}{1}{7}{{1}}%
\regfield{RCIE}{1}{6}{{1}}%
\regfield{Parity}{2}{4}{{0}}%
\regfield{Size}{2}{2}{{0}}%
\regfield{Reserved}{1}{1}{{0}}%
\regfield{SP}{1}{0}{{0}}
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.6\textwidth]\begin{reglist}[00000]
\itemsep-1.5ex
\item[TCIE] Transmit character interrupt enable.
\item[RCIE] Receive character interrupt enable.
\item[Parity] 00: none, 10: even, 11: odd.
\item[Size] 00: 8 bits, 10: 9 bits, 11: 7 bits, excluding the parity.
\item[SP] 0: one stop bit, 1: two stop bits.
%\item[Stop Bits] Meaning
%\item[0] 1 Stop bit
%\item[1] 2 Stop bits
%\item
%\item[Parity] Meaning
%\item[00] No parity
%\item[01] Reserved
%\item[10] Even parity
%\item[11] Odd parity
%\item
%\item[Data bits]
%\item[0] 8 bits
%\item[9] 9 bits
\end{reglist}\end{regdesc}

\begin{register}{H}{UART1 status register UART1\_STAT}{0x2c}
\label{uart1stat}
\regfield{Reserved}{27}{5}{{0}}%
\regfield{TC}{1}{4}{{0}}%
\regfield{PE}{1}{3}{{0}}%
\regfield{RC}{1}{2}{{0}}%
\regfield{RF}{1}{1}{{0}}%
\regfield{FE}{1}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[TC] Transmit completed. Set directly to 1 when a character was transmitted. Automatically cleared when writing new character to the data register or when writing 0 in the TC bit in \mbox{UART1\_STAT}.
\item[PE] Parity error. Set to 1 if parity is enabled and there is a parity error while receiving. Automatically cleared when data register is read or when writing 0 in the PE bit in UART1\_STAT.
\item[RC] Receive completed. Set to 1 when a character was received. Automatically cleared when data register is read or when writing 0 in the RC bit in UART1\_STAT.
\item[RF] Receive failed. Set to 1 when failed receiving (invalid start bit). Automatically cleared when data register is read or when writing 0 in the RF bit in UART1\_STAT.
\item [FE] Frame error. Set to 1 when a low is detected at the position of the (first) stop bit. Automatically cleared when data register is read or writing a 0 in the FE bit in UART1\_STAT.
\end{reglist}\end{regdesc}


\subsection{I2C1 -- Inter-Integrated Circuit master-only controller}
General purpose I\textsuperscript{2}C peripheral, with programmable baud rate prescaler, start- and stopbit generation, no clock stretching, no arbitration, Standard mode (Sm) only.

\begin{register}{H}{I2C1 control register I2C1\_CTRL}{0x40}
\label{i2c1ctrl}
\regfield{BAUD}{16}{16}{{0}}%
\regfield{Reserved}{5}{11}{{0}}%
\regfield{DPG}{1}{10}{{0}}%
\regfield{START}{1}{9}{{0}}%
\regfield{STOP}{1}{8}{{0}}%
\regfield{Reserved}{3}{5}{{0}}%
\regfield{RCIE}{1}{4}{{0}}%
\regfield{TCIE}{1}{3}{{0}}%
\regfield{FM}{1}{2}{{0}}%
\regfield{Reserved}{2}{0}{{0}}
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000000i]
\item [BAUD] Baud rate prescaler. Number of system clock pulses minus 1 for \textbf{one-half} bit time.
Note: because of the 50\,MHz system frequency, the lowest I\textsuperscript{2}C clock frequency is 763\,Hz.
\item [DPG] Disable STOP generation after Acknowledge Fail. Can be used to send a repeated START.
\item [START] Send a START on next byte send. Cleared by hardware when transmission ends.
\item [STOP] Send a STOP after next byte send or received. Cleared by hardware when transmission ends.
\item [RCIE] Receive Complete interrupt enable.
\item [TCIE] Transmit Complete interrupt enable.
\item [FM] Fast mode 2:1 (SCL 2/3 low, 1/3 high)
\end{reglist}\end{regdesc}

\begin{register}{H}{I2C1 status register I2C1\_STAT}{0x44}
\label{i2c1stat}
\regfield{Reserved}{26}{6}{{0}}%
\regfield{AF}{1}{5}{{0}}%
\regfield{RC}{1}{4}{{0}}%
\regfield{TC}{1}{3}{{0}}%
\regfield{RnW}{1}{2}{{0}}%
\regfield{Reserved}{2}{0}{{0}}
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000000i]
\item [AF] Acknowledge Fail, set when no target responded.
\item [RC] Receive Complete, including sending STOP. Cleared by hardware when I2C1\_DATA is read.
\item [TC] Transmission Complete, including sending STOP. Cleared by hardware when I2C1\_DATA is written.
\item [RnW] Indicates transmitting (0) or receiving (1)
\end{reglist}\end{regdesc}

\begin{register}{H}{I2C1 data register I2C1\_DATA}{0x48}
\label{i2c11data}
\regfield{Data}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[000000000]
\itemsep-1.5ex
\item[Write] The data is written to an internal buffer and transmitted.
\item[Read] The last received data is read.
\end{reglist}\end{regdesc}
Data size depends on the Size field in the SPI1 Control Register. Data is right aligned.


\subsection{SPI1 -- Serial Peripheral Interface}
General purpose SPI master peripheral, with prescaler, 8/16/24/32 bits data exchange, hardware NSS and interrupt.

\begin{register}{H}{SPI1 control register SPI1\_CTRL}{0x60}
\label{spi1ctrl}
\regfield{Reserved}{4}{28}{{0}}%
\regfield{NSS setup}{8}{20}{{0}}%
\regfield{NSS hold}{8}{12}{{0}}%
\regfield{Reserved}{1}{9}{{0}}%
\regfield{Prescaler}{3}{8}{{0}}%
\regfield{Reserved}{2}{6}{{0}}%
\regfield{Size}{2}{4}{{0}}%
\regfield{TIE}{1}{3}{{0}}%
\regfield{CPOL}{1}{2}{{0}}%
\regfield{CPHA}{1}{1}{{0}}%
\regfield{Reserved}{1}{0}{{0}}
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000000i]
\item [NSS setup] Number of system clock pulses after NSS active before transfer starts
\item [NSS hold] Number of system clock pulses before NSS inactive after transfer ends
\item [Prescaler]
\begin{description}\itemsep-7pt
\item[000] /2
\item[001] /4
\item[010] /8
\item[011] /16
\item[100] /32
\item[101] /64
\item[110] /128
\item[111] /256
\end{description}
Note: because of the 50\,MHz system frequency, the lowest SPI clock frequency is 195.3125\,kHz.
\item [Size]
\begin{description}\itemsep-7pt
\item[00] 8 bits
\item[01] 16 bits
\item[10] 24 bits
\item[11] 32 bits
\end{description}
\item [TIE] Transfer complete interrupt enable
\item [CPOL] Clock polarity
\item [CPHA] Transfer phase
\end{reglist}\end{regdesc}

\begin{register}{H}{SPI1 status register SPI1\_STAT}{0x64}
\label{spi1stat}
\regfield{Reserved}{28}{4}{{0}}%
\regfield{TC}{1}{3}{{0}}%
\regfield{Reserved}{3}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\item [TC] Transfer complete
\end{reglist}\end{regdesc}

\begin{register}{H}{SPI1 data register SPI1\_DATA}{0x68}
\label{spi1data}
\regfield{Data}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[000000000]
\itemsep-1.5ex
\item[Write] The data is written to an internal buffer and transmitted.
\item[Read] The last received data is read.
\end{reglist}\end{regdesc}
Data size depends on the Size field in the SPI1 Control Register. Data is right aligned.


\subsection{SPI2 -- Serial Peripheral Interface}
SPI master peripheral dedicated for SD card access, with prescaler and 8/16/24/32 bits data exchange.
\begin{register}{H}{SPI2 control register SPI2\_CTRL}{0x70}
\label{spi2ctrl}
\regfield{Reserved}{21}{11}{{0}}%
\regfield{Prescaler}{3}{8}{{0}}%
\regfield{Reserved}{2}{6}{{0}}%
\regfield{Size}{2}{4}{{0}}%
\regfield{Reserved}{1}{3}{{0}}%
\regfield{CPOL}{1}{2}{{0}}%
\regfield{CPHA}{1}{1}{{0}}%
\regfield{Reserved}{1}{0}{{0}}
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000000i]
\item [Prescaler]
\begin{description}\itemsep-7pt
\item[000] /2
\item[001] /4
\item[010] /8
\item[011] /16
\item[100] /32
\item[101] /64
\item[110] /128
\item[111] /256
\end{description}
Note: because of the 50\,MHz system frequency, the lowest SPI clock frequency is 195.3125\,kHz.
\item [Size]
\begin{description}\itemsep-7pt
\item[00] 8 bits
\item[01] 16 bits
\item[10] 24 bits
\item[11] 32 bits
\end{description}
\item [CPOL] Clock polarity
\item [CPHA] Transfer phase
\end{reglist}\end{regdesc}

\begin{register}{H}{SPI2 status register SPI2\_STAT}{0x74}
\label{spi2stat}
\regfield{Reserved}{28}{4}{{0}}%
\regfield{TC}{1}{3}{{0}}%
\regfield{Reserved}{3}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\item [TC] Transfer complete
\end{reglist}\end{regdesc}

\begin{register}{H}{SPI2 data register SPI2\_DATA}{0x78}
\label{spi2data}
\regfield{Data}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[000000000]
\itemsep-1.5ex
\item[Write] The data is written to an internal buffer and transmitted.
\item[Read] The last received data is read.
\end{reglist}\end{regdesc}
Data size depends on the Size field in the SPI2 Control Register. Data is right aligned.


\subsection{TIMER1 -- a simple timer}
Simple 32-bit timer peripheral for time base generation, with interrupt.

\begin{register}{H}{TIMER1 control register TIMER1\_CTRL}{0x80}
\label{timer1ctrl}
\regfield{Reserved}{27}{5}{{0}}%
\regfield{TIE}{1}{4}{{0}}%
\regfield{Reserved}{3}{1}{{000}}%
\regfield{EN}{1}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[EN] Enable the timer
\item[TIE] Timer compare match interrupt enable
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER1 status register TIMER1\_STAT}{0x84}
\label{timer1stat}
\regfield{Reserved}{27}{5}{{0}}%
\regfield{TCI}{1}{4}{{0}}%
\regfield{Reserved}{4}{0}{{0000}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[TCI] Timer compare match interrupt. Set to 1 on compare match between the timer Count register and the Compare Match register. Must be cleared by software by writing a 0.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER1 count register TIMER1\_CNTR}{0x88}
\label{timer1cntr}
\regfield{CNTR}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[CNTR] This register holds the counted clock pulses on the timer. This register may be written by software.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER1 compare timer T register TIMER1\_CMPT}{0x8c}
\label{timer1cmpt}
\regfield{CMPT}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[CMPT] This register holds the value at which the counter register is compared. On CNTR compares to greater than or equal to CMPT, the counter register will be cleared and the TCI flag will be set (both in the next clock cycle).
\end{reglist}\end{regdesc}

\subsection{TIMER2 -- a more elaborate timer}
General purpose 16-bit timer with Output Compare and PWM generation capabilities, preload and interrupts.

\begin{register}{H}{TIMER2 control register TIMER2\_CTRL}{0x90}
\label{timer2ctrl}
%\regfield{Reserved}{24}{8}{{0}}%
\regfield{FOCC}{1}{31}{{0}}%
\regfield{FOCB}{1}{30}{{0}}%
\regfield{FOCA}{1}{29}{{0}}%
\regfield{FOCT}{1}{28}{{0}}%
\regfield{PHAC}{1}{27}{{0}}%
\regfield{MODEC}{3}{24}{{000}}%
\regfield{PHAB}{1}{23}{{0}}%
\regfield{MODEB}{3}{20}{{000}}%
\regfield{PHAA}{1}{19}{{0}}%
\regfield{MODEA}{3}{16}{{000}}%
\regfield{PHAT}{1}{15}{{0}}%
\regfield{MODET}{3}{12}{{000}}%
\regfield{PREC}{1}{11}{{0}}%
\regfield{PREB}{1}{10}{{0}}%
\regfield{PREA}{1}{9}{{0}}%
\regfield{PRET}{1}{8}{{0}}%
\regfield{CIE}{1}{7}{{0}}%
\regfield{BIE}{1}{6}{{0}}%
\regfield{AIE}{1}{5}{{0}}%
\regfield{TIE}{1}{4}{{0}}%
\regfield{OS}{1}{3}{{0}}%
\regfield{Reserved}{2}{1}{{00}}%
\regfield{EN}{1}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[000000]
\itemsep-1.5ex
\item [FOCC] Force Output Compare match C.
\item [FOCB] Force Output Compare match B.
\item [FOCA] Force Output Compare match A.
\item [FOCT] Force Output Compare match T.
\item [PHAC] Register C start phase.
\item[MODEC] Register C mode.
\item [PHAB] Register B start phase.
\item[MODEB] Register B mode.
\item [PHAA] Register A start phase.
\item[MODEA] Register A mode.
\item[PHAT] Register T start phase.
\item[MODET] Register T mode.
\item[PREC] Enable compare register C preload.
\item[PREB] Enable compare register B preload.
\item[PREA] Enable compare register A preload.
\item[PRET] Enable compare register T preload.
\item[CIE] Timer compare match C interrupt enable
\item[BIE] Timer compare match B interrupt enable
\item[AIE] Timer compare match A interrupt enable
\item[TIE] Timer compare match T interrupt enable
\item[OS] One-shot mode
\item[EN] Enable the timer
\end{reglist}\end{regdesc}

If none of the FOC$x$ bits are 1, MODET and MODEA/B/C have the following meaning:
\begin{description}\itemsep-7pt
\item[000] Output off
\item[001] Toggle on compare match
\item[010] Set high on compare match
\item[011] Set low on compare match
\item[100] Edge-aligned PWM (only A/B/C, for T not allowed)
\item[101] not allowed
\item[110] not allowed
\item[111] not allowed
\end{description}
If at least one of the FOC$x$ bits is 1, MODET and MODEA/B/C have the following meaning:
\begin{description}\itemsep-7pt
\item[000] not allowed
\item[001] Toggle output compare
\item[010] Set high output compare
\item[011] Set low output compare
\item[100] not allowed
\item[101] not allowed
\item[110] not allowed
\item[111] not allowed
\end{description}
In this case, the CTRL register is not written and keeps its original setting.

\begin{register}{H}{TIMER2 status register TIMER2\_STAT}{0x94}
\label{timer2stat}
\regfield{Reserved}{24}{8}{{0}}%
\regfield{CCI}{1}{7}{{0}}%
\regfield{BCI}{1}{6}{{0}}%
\regfield{ACI}{1}{5}{{0}}%
\regfield{TCI}{1}{4}{{0}}%
\regfield{Reserved}{4}{0}{{0000}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[CCI] Timer compare match A interrupt. Set to 1 on compare match between the timer Count register and the Compare Match C register. Must be cleared by software by writing a 0.
\item[BCI] Timer compare match A interrupt. Set to 1 on compare match between the timer Count register and the Compare Match B register. Must be cleared by software by writing a 0.
\item[ACI] Timer compare match A interrupt. Set to 1 on compare match between the timer Count register and the Compare Match A register. Must be cleared by software by writing a 0.
\item[TCI] Timer compare match T interrupt. Set to 1 on compare match between the timer Count register and the Compare Match T register. Must be cleared by software by writing a 0.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER2 count register TIMER2\_CNTR}{0x98}
\label{timer2cntr}
\regfield{Reserved}{16}{16}{{0}}%
\regfield{CNTR}{16}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[CNTR] This register holds the counted clock pulses on the timer. This register may be written by software. Rolls over when CNTR compare greater than or equal to CMPT on the next clock cycle.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER2 compare timer T register TIMER2\_CMPT}{0x9c}
\label{timer2cmpt}
\regfield{Reserved}{16}{16}{{0}}%
\regfield{CMPT}{16}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[CMPT] This register holds the value at which the Count register is compared. On CNTR compares to greater than or equal to CMPT, the Count register will be cleared and the TCI flag will be set (both in the next clock cycle).
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER2 prescaler register TIMER2\_PRSC}{0xa0}
\label{timer2prsc}
\regfield{Reserved}{16}{16}{{0}}%
\regfield{PSRC}{16}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[PRSC] This register holds the prescaler of the timer. This register may be written by software. Whenever the internal prescaler is equal to or greater than this register, the internal prescaler is reset. This register should only be written when the timer is stopped. Writing this register resets the internal prescaler.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER2 compare timer A register TIMER2\_CMPA}{0xa4}
\label{timer2cmpa}
\regfield{Reserved}{16}{16}{{0}}%
\regfield{CMPA}{16}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[CMPA] This register holds the value at which the Count register is compared. On CNTR compares to greater than or equal to CMPA, the ACI flag will be set in the next clock cycle.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER2 compare timer B register TIMER2\_CMPB}{0xa8}
\label{timer2cmpb}
\regfield{Reserved}{16}{16}{{0}}%
\regfield{CMPB}{16}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[CMPB] This register holds the value at which the Count register is compared. On CNTR compares to greater than or equal to CMPB, the BCI flag will be set in the next clock cycle.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMER2 compare timer C register TIMER2\_CMPC}{0xac}
\label{timer2cmpc}
\regfield{Reserved}{16}{16}{{0}}%
\regfield{CMPC}{16}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item[CMPC] This register holds the value at which the Count register is compared. On CNTR compares to greater than or equal to CMPC, the CCI flag will be set in the next clock cycle.
\end{reglist}\end{regdesc}

\subsection{TIME -- RISC-V system timer}
Note: the external timer interrupt has to be enabled by writing a 1 to \lstinline|mie.MTIE|.\\
\begin{register}{H}{TIME external timer register TIME}{0xf0}
\label{time}
\regfield{TIME}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item This register holds the low 32 bits of the external timer. Currently read-only.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMEH external timer register TIME}{0xf4}
\label{timeh}
\regfield{TIMEH}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item This register holds the upper 32 bits of the external timer. Currently read-only.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMECMP external timer compare register TIMECMP}{0xf8}
\label{timecmp}
\regfield{TIMECMP}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item This register holds the low 32 bits of the external timer compare register.
\end{reglist}\end{regdesc}

\begin{register}{H}{TIMECMPH external timer compare register TIMECMP}{0xfc}
\label{timecmph}
\regfield{TIMECMPH}{32}{0}{{0}}%
\reglabel{Reset}\regnewline%
\end{register}
\begin{regdesc}[0.8\textwidth]\begin{reglist}[0000]
\itemsep-1.5ex
\item This register holds the upper 32 bits of the external timer compare register.
\end{reglist}\end{regdesc}

\end{document}